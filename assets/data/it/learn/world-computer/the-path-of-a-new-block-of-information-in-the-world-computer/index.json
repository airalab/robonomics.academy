{"hash":"39646b78023bddea786f995e516360c6cbdb9af0","data":{"course":{"id":"9efcff2b3572f778a6c0fa168a5d0d04","title":"Parte 4: Il Percorso di un Nuovo Blocco di Informazioni nel Computer Mondiale","description":"La quarta e ultima parte della nostra lezione è \"Il Computer Mondiale nella Tua Casa.\" Dopo questo, inizierò a registrare screencast per la parte pratica delle sessioni.","content":"\nLa quarta e ultima parte della nostra lezione è \"Il Computer Mondiale nella Tua Casa.\" Dopo questo, inizierò a registrare screencast per la parte pratica delle sessioni.\n\nOra cercheremo di riassumere quasi tutta la teoria che abbiamo coperto finora in termini di un processo. Il processo che descrive il percorso di un blocco di informazioni nel computer mondiale. Cominciamo di nuovo tornando al tema di web3 e al concetto di blockchain. La frase \"blocco\" o \"blocco di informazioni\" può essere considerata identica quando ci allontaniamo dagli ultimi 10 anni e prendiamo in considerazione una teoria più generale, come esplorato nelle parti precedenti delle lezioni. Il concetto di un \"blocco di informazioni\" si allinea con web3, ma non necessariamente con blockchain. Anche senza progetti crypto, dobbiamo capire che quando si forma la teoria del computer mondiale senza fare riferimento alla formazione di blocchi di informazioni, attualmente è difficile immaginare altri modelli. Quindi, considereremo il percorso di un blocco di informazioni in tutto il computer mondiale, non perché è blockchain, ma perché, per ora, non ci sono altri modi per concettualizzare l'esistenza del computer mondiale se non elaborando informazioni in porzioni specifiche.\n\nBlocco di informazioni = blocco in web3, ma senza blockchain e senza alcuna influenza di progetti crypto. Dobbiamo attualmente considerare la formazione di blocchi di informazioni quando si discute della teoria del computer mondiale. Ora passiamo al primo punto. Ho cercato di trovare analogie vicine dalla vita di tutti i giorni per aiutare a illustrare il percorso di un blocco di informazioni nel computer mondiale. L'analogia che ho scelto è il movimento di un autobus lungo un percorso. Il nostro primo punto di incontro è la fermata dell'autobus.\n\nHo contrassegnato le transazioni in rosa come piccoli punti. Immaginiamo una tipica fermata dell'autobus dove le persone si riuniscono, aspettando un autobus che opera secondo un orario. Se non consideriamo il trambusto delle grandi città, dove gli autobus sono sempre in ritardo, tutti nel mondo sanno generalmente che il treno da villaggio A a villaggio B arriva sempre intorno alle 7:15 del mattino. Le transazioni che gli utenti vogliono inviare al computer mondiale si raccolgono in una certa fermata dell'autobus e aspettano che arrivi l'autobus.\n\nEcco come è formato il nostro blocco. Immagina: l'autobus arriva e ogni persona inizia a salire uno per uno, prendendo il proprio posto. L'autobus segue poi il suo percorso. Nel nostro caso, il blocco di informazioni supera la prima frontiera. Le nostre transazioni, in qualche forma, si sono stabilite sull'autobus e hanno superato la barriera iniziale. Utilizzerò principalmente la terminologia di Polkadot e la terza parte dovrebbe aver meglio spiegato il concetto di computer mondiale nel confronto tra Ethereum e Polkadot. La mia opinione personale, e probabilmente la maggior parte degli ingegneri oggi sarebbe d'accordo, è che la rappresentazione di un computer mondiale eterogeneo multicentrico è meglio implementata in Polkadot. Tuttavia, passeremo comunque attraverso i termini ereditati da Ethereum, ma verso la fine di questa parte della lezione.\n\nQual è la linea che separa la fermata dell'autobus dal movimento successivo dell'autobus? Questa linea rappresenta i collatori della rete - partecipanti ai nodi della rete che raccolgono le transazioni. Puoi pensare a un collatore non come un autista di autobus ma come un controllore che rimane alla fermata dell'autobus. In altre parole, questo controllore controlla se hai un biglietto quando entri sull'autobus. Non ricontrolla nel database quanto sia valido il biglietto ma guarda i parametri di base del biglietto e controlla se tutto sembra a posto. In realtà, i collatori eseguono quasi tutti i calcoli necessari, verificando il numero del biglietto e altri dati, ma non sono tenuti a garantire che il controllo sia eseguito correttamente. Pertanto, i collatori sono controllori che rimangono alla fermata dell'autobus, garantendo principalmente l'imbarco dei passeggeri, il posizionamento e l'invio dell'autobus lungo il percorso.\n\nOltre il confine disegnato, entriamo nella prima area di convalida dove si trovano i paravalidatori. Questi sono validatori dell'intero ecosistema, dell'intera rete, specificamente assegnati per un certo periodo per controllare ogni transazione e quindi eseguire calcoli effettivi nel computer mondiale. Il nostro blocco di informazioni non ancora completamente formato è contrassegnato da una linea tratteggiata. È ancora un blocco di informazioni candidato poiché non ha subito alcuna verifica effettiva. Il collatore, che ha raccolto il blocco di informazioni e controllato le transazioni all'ingresso, non partecipa in alcun modo alla sicurezza informatica dei calcoli effettuati. Il suo compito è solo di sistemare tutte le transazioni e formare il primo blocco. In questa fase, inizia la trasformazione da un blocco candidato a un blocco di informazioni reale.\n\nL'ho diviso in tre parti, ma ho dimenticato un'altra. Consideriamo quindi quattro parti di questo blocco candidato. La parte superiore, conosciuta dagli utenti di varie applicazioni web3 come l'intestazione o l'intestazione del blocco, è la quintessenza, il pezzo di informazione più popolare che circola e si riflette dall'esploratore di blocchi ai client console di tutti i nodi che fanno mining, staking, e così via. L'intestazione è un elemento chiave del blocco, ma è praticamente formata nell'ultima fase a questo punto.\n\nInnanzitutto, abbiamo le nostre richieste effettive per transizioni di stato o calcoli. C'è un elenco di modifiche che devono essere apportate: convertire A in A', B in B', C in C', applicando loro un insieme di algoritmi. Per questo, costruiremo immediatamente un'altra barriera e la supereremo per eseguire questa parte del lavoro, e poi procederemo oltre. Già nella fase di preparazione del blocco, dobbiamo superare la seconda barriera all'interno del computer mondiale per passare agli algoritmi che devono essere applicati per preparare il blocco. Come ho già detto, teoricamente, il controllore alla fermata dell'autobus fa lo stesso qui, ma non ci farei troppo caso. La fase di preparazione del blocco, specialmente quando parliamo di esempi contemporaneamente da Polkadot ed Ethereum come computer mondiale, differiscono leggermente e ci mostrano l'irrilevanza dei controlli in questa fase perché è proprio al secondo passo, dopo aver superato la prima barriera e ricevuto il blocco di informazioni dai collatori, che iniziano i calcoli degni di attenzione di questo computer mondiale.\n\n\nPer effettuare questi calcoli, il validatore, in questa fase, può farlo solo rivolgendosi alla catena di rilancio, al database centrale, e prendendo da lì gli algoritmi dal runtime. Nel caso di Ethereum, erano le stesse macchine virtuali nel concetto architettonico precedente, che potevano essere applicate, quindi non c'era bisogno di andare da nessuna parte. Quasi ogni nodo aveva una copia completa degli algoritmi che potevano essere applicati. Ma in termini di una rete eterogenea, dove ogni segmento o ogni singola catena potrebbe avere il proprio set di algoritmi, un validatore, prima di eseguire effettivamente tutte le transizioni, i calcoli ottenuti sotto forma di un candidato blocco dal collatore, deve consultare. Deve consultare la catena di rilancio, consultare la blockchain principale nella rete e prendere da lì gli algoritmi necessari, applicarli e eseguire le transizioni di stato.\n\nDurante l'esecuzione dei calcoli, viene contemporaneamente formato un albero di Merkle, e non ci soffermeremo su di esso perché gli alberi di Merkle non sono così complicati dal punto di vista dell'informatica. Tuttavia, noto che per capire come applicarli in ingegneria e nell'architettura di un progetto, come vengono applicati, non solo leggendo su Wikipedia, è necessario faticare un po', immaginare esempi. In questo esempio, non ci addentreremo troppo, ma penso che per coloro che sono già familiari con alcune definizioni di base, hanno letto sugli alberi di Merkle, diventerà un po' più chiaro su come e in quali momenti viene assemblato un altro albero di Merkle. L'albero di Merkle si forma quando effettivamente eseguiamo calcoli e compaiono i valori di output. Questi valori di output vengono impacchettati in un formato ad albero binario, quindi viene eseguita l'addizione tra di essi nel linguaggio informatico, e il nodo superiore raggiunge l'intestazione. Denotiamolo con una grande lettera \"H.\" È un aspetto piccolo e piacevole considerare tali schemi.\n\nIn questo schema, possiamo notare come l'intestazione del blocco sia effettivamente correlata ai calcoli eseguiti all'interno. Guardiamo di nuovo - il nostro candidato blocco è arrivato dal collatore. C'è un insieme di transazioni che devono essere eseguite, eseguire calcoli. Il validatore ha attraversato un altro confine interno, un altro, dietro agli algoritmi, li ha applicati e ha registrato tutti i risultati al livello più basso dell'albero di Merkle. Gli altri nodi sono essenzialmente sistemici. Non provengono da alcun dato; non provengono da nessuna parte. Al secondo livello, il nodo non proviene da alcuna informazione. Viene ottenuto sommando i valori in queste due foglie, e quando saliamo con voi, otteniamo solo la radice di questo albero, che è sufficiente per proteggere tutti i valori di output. Non otterremo la stessa intestazione se cambiamo uno qualsiasi di questi calcoli. E questa è una delle caratteristiche magiche e semplici, come lo storage orientato all'hash, di come possiamo proteggere un intero blocco di informazioni parlando solo di un'intestazione. Pertanto, le intestazioni sono così importanti e svolgono un ruolo fondamentale anche nelle architetture quando passiamo da una catena o da una macchina virtuale a molte combinate nella rete. Ci basta assicurarci la sicurezza di memorizzare le intestazioni per essere sicuri che tutte le transazioni eseguite nella fase di preparazione del blocco siano state eseguite correttamente e non possono essere sostituite.\n\nE un campo è ancora rimasto vuoto. Nel processo di preparazione del blocco di informazioni, è il campo dell'autore, cioè il validatore che ha effettivamente eseguito tutte le modifiche, preparato l'albero di Merkle e registrato l'intestazione. Poiché stiamo considerando un esempio con l'autobus che si muove lungo il percorso dalla fermata, chiamiamo il validatore un \"controllore\" che entra direttamente nell'autobus, passa da ogni posto, si avvicina a ogni persona, controlla effettivamente ciò che è scritto sui loro biglietti, fa qualche segno, lo convalida e, di conseguenza, mette la loro firma. Il controllore, ad esempio, numero 134, significa, naturalmente, che ogni validatore ha un identificatore unico, il loro indirizzo, e lo abbiamo anche rinominato in modo univoco qui.\n\nE sembra che a questo punto avremmo potuto ombreggiare e rendere più audaci i confini del nostro blocco, ma no, e questo è uno dei cambiamenti interessanti che sono avvenuti negli ultimi 5 anni in termini di ecosistemi decentralizzati, ovvero il passaggio dal proof of work. Quando i validatori della rete, all'epoca i minatori, non dovevano mai coordinarsi tra loro. Producevi un blocco e lo inviavi alla rete e andavi avanti. In realtà, non era un consenso di consenso concordato. Era un consenso di accordo ovvio con il fatto che era accaduto. Cosa interessante cambia quando l'architettura diventa più complessa, e ci siamo avvicinati da un semplice calcolatore come Bitcoin con un registro verso un vero computer virtuale, è che ad ogni stadio, la connettività dei partecipanti che garantiscono la sicurezza e la produzione di blocchi è aumentata. Perché, in realtà, nessuno che rischia il proprio capitale, colui che garantisce questa sicurezza e vuole guadagnare elaborando le tue transazioni, ha qualcosa da perdere, a differenza del proof of work. Nel proof of work, hai acquistato l'attrezzatura, sì, hai investito denaro, hai speso energia, ma in realtà non c'è alcuna protezione contro il fatto che puoi attaccare la rete con la tua potenza, lo stesso attacco del 51%, dove qualcuno con molti minatori può cercare di riscrivere la catena.\n\nOra stiamo parlando della prova di puntata, dove un deposito è già stato effettuato e, se fai qualcosa di sbagliato, ne verrà prelevata una parte, come penalità. Tutti i nodi, assolutamente, in tutte le architetture che attualmente osservo, i meccanismi per la messaggistica tra i validatori hanno iniziato a comparire rapidamente nella fase di preparazione del blocco. In Polkadot, non è diverso. Qualsiasi validatore di una parachain separata che raccoglie un blocco conosce gli indirizzi o ha già stabilito contatto con altri 15-63 validatori che sono con te in questa epoca, per un certo periodo temporaneo, come validatori, e ognuno di loro diventa casualmente un produttore di blocchi in un certo momento. Ma essere nominato produttore non annulla un componente molto importante di questo processo. Non smetti di interagire con gli altri partecipanti. C'è sempre un pool di validatori assegnati a una specifica epoca, a uno slot temporale specifico, per convalidare una particolare parachain o segmento del computer mondiale. Indipendentemente dal fatto che tu sia un validatore-controller specificamente assegnato a produrre il prossimo blocco nel computer mondiale di questo segmento, rimani comunque in contatto con gli altri validatori e hai un contatto costante con loro.\n\nPerché è necessario questo costante contatto? Risulta essere piuttosto semplice. Non vogliamo, quando entriamo nella parte interna, avere paura o preoccuparci di aver eseguito correttamente le operazioni. Sorprendentemente, è vantaggioso per qualsiasi validatore, prima di procedere, rivolgersi ai propri colleghi assegnati alla validazione e chiedere loro di rivedere i calcoli. Questa verifica è informale, quindi anche se non utilizziamo alcun registro in un database immutabile delle richieste di verifica e dei risultati di questa verifica, il controller designato, dopo aver parlato con il pool di validatori, raccoglie comunque risposte aggiuntive da tutti i validatori assegnati a questa parachain o segmento di rete. Insieme alle conferme aggiuntive, il controller passa alla fase successiva. Ma anche qui, non è proprio così semplice. A questo punto, deve essere eseguito un altro processo. È importante notare che a questo punto, il nostro blocco di informazioni è ancora un blocco candidato, e il regolamento delle informazioni è già in corso nello storage. Né alla fine, né dopo aver creato e sigillato il blocco e averlo collegato con un archivio nella parte finale, cioè qui, in questa parte centrale dove vengono effettuati tutti i calcoli, le informazioni vengono salvate nello storage. Pertanto, il nostro controller, oltre a parlare con i propri colleghi, si assicura anche dello storage dei dati in qualche storage, che è anche piuttosto metafisico perché nel momento in cui si comunica con altri validatori, questo storage si riempie. Come viene verificato ciò? Dovremo passare alla fase successiva.\n\nIn sintesi, per completare la parte centrale, diamo un'occhiata di nuovo. Abbiamo ancora solo un blocco candidato all'inizio. Sì, tutte le transazioni sono approssimativamente calcolate da qualche parte alla fermata dell'autobus, ognuno ha preso il proprio posto in base al biglietto. Abbiamo superato il primo confine, che è essenzialmente il contatto diretto stabilito tra i validatori e i collatori di blocchi. In Ethereum e Polkadot, questi sono schemi leggermente diversi ora. Ma tutto ciò che accade sul lato sinistro all'inizio non fornisce sicurezza informatica per i dati e i calcoli. È solo preparazione. Una volta superato e entrati nell'ambiente dell'attenzione dei validatori, il lavoro con il blocco di informazioni nel computer mondiale inizia. Un validatore selezionato casualmente, nel nostro caso, con un percorso in autobus - un controllore, effettivamente passa attraverso ciascuno dei posti, controlla il biglietto, controlla e esegue tutti i calcoli che sono stati fatti, raccoglie tutte le informazioni in un albero. Il nodo radice risultante di questo albero diventa l'intestazione del blocco proposto. Il validatore che effettivamente esegue tutti i calcoli con questo blocco di informazioni comunica con gli altri partecipanti che svolgono una funzione simile per lo stesso percorso in uno slot temporale non definito. E mentre comunica con loro e chiede loro di verificare tutti i calcoli, stiamo effettivamente riempiendo un certo archivio di dati nella rete. Non si tratta di un archivio fisico specifico; non c'è un indirizzo IP specifico, né un disco rigido specifico su cui tutti caricano tramite qualche schema VPN o login e password, ovviamente no. Nel processo di comunicazione con gli altri validatori, i dati rimangono sulle loro macchine locali, e questi dati parteciperanno ulteriormente alla trasformazione di questo candidato in un nuovo blocco di informazioni. In sostanza, il blocco sigillato che sarà sistemato nella catena di rilancio viene raccolto. Abbiamo assemblato un blocco. Tutti i metadati attorno ai calcoli sono già compilati, il che significa che possiamo provare a passare alla prossima frontiera.\n\nIn questo momento, approfondiamo il passaggio del prossimo confine. L'aspetto più cruciale nella fase finale diventa l'intestazione del blocco. Siamo meno preoccupati dell'esecuzione dei calcoli; possiamo semplificare la nostra prospettiva qui, poiché i calcoli possono variare in base all'architettura, che sia Ethereum o Polkadot. Il punto chiave è che, nella fase intermedia, da quanto osservo nella teoria e nella pratica dell'implementazione del concetto di computer mondiale, la maggior parte dei calcoli avviene a un livello intermedio. L'ultimo livello rimane solo per eseguire controlli essenziali. Quasi tutti questi controlli in un'architettura multi-chain sono legati alla concatenazione o fusione delle intestazioni dei blocchi in un unico blocco.\n\n\nNella parte finale del nostro viaggio, l'elemento più importante nel blocco di informazioni del computer mondiale diventa la pietra angolare - l'intestazione. Il secondo componente riguarda maggiormente le meta-informazioni. Se l'intestazione è il risultato effettivo di tutti i calcoli, le meta-informazioni aggiuntive trasmesse consistono di ricevute e firme dei validatori che hanno partecipato alla fase intermedia di questo processo. Nella fase finale, possiamo visualizzare l'intera immagine unicamente come l'assemblaggio dello stesso albero, non come un elenco di transazioni. Nella parte finale della catena di rilancio, l'aspetto cruciale è l'assemblaggio delle intestazioni da molti processi simili, ma collegati a segmenti diversi del computer mondiale, diverse parachains.\n\nOgni parachain, ogni insieme di validatori - abbiamo discusso un esempio, ma in realtà, tali preparativi di blocco per le parachains avvengono 30-40 volte. Il numero di slot parachain o il numero di reti L2 in Ethereum comporterà un numero simile di processi con un'architettura simile. Tuttavia, nella fase finale, vedremo un'immagine approssimativamente identica ovunque - come l'intestazione del blocco sarà formata da una moltitudine di intestazioni da altri blocchi. In questo processo, dobbiamo introdurre un'altra entità e tornare indietro attraverso il confine alla seconda fase.\n\nFinalizzatori. In realtà, sono anche validatori, ma validatori della catena di rilancio. Nell'architettura di Polkadot, abbiamo mille validatori divisi in due gruppi. Il primo, un gruppo molto piccolo, è responsabile solo per la formazione dell'intestazione del blocco e di un nuovo blocco composto dalle intestazioni dei blocchi dello Stato dei blocchi degli Stati. Il secondo gruppo - validatori delle parachain - è ulteriormente diviso in molti sottogruppi, ma questo gruppo è chiamato validatori delle parachain. Nelle reti L2 sopra Ethereum, questa storia guadagnerà alla fine una maggiore comprensione, più denominatori. Per ora, concentriamoci sull'architettura di Polkadot. I finalizzatori, oltre a controllare un insieme aggiuntivo di meta-informazioni e ricontrollare un validatore con un ID specifico, scelto casualmente per generare questo blocco di tutti i blocchi, aiutano anche a ricontrollare le meta-informazioni, controllare e assemblare tutte le intestazioni in una. È un po' complesso, sì, se lo guardiamo dal punto di vista dell'assemblaggio dell'albero.\n\nOltre a questo, nell'architettura di Polkadot e in Ethereum con gli ultimi cambiamenti, si verifica un controllo di disponibilità dei dati. Per questo, i finalizzatori visitano i validatori delle parachain e cercano di richiedere informazioni effettive su ciascun blocco memorizzato nella rete. Se ricevono dati da almeno 1/3 dei validatori, utilizzando una tecnologia che consente la memorizzazione ridondante delle informazioni, e successivamente, se qualcuno le perde, uno o due o tre validatori possono comunque ripristinarle, c'è una soglia critica al 1/3. Se 1/3 dei nodi risponde e dice che abbiamo dati sul blocco in produzione, i finalizzatori dicono al blocco che è già un blocco di informazioni completamente formato, che tutti i calcoli sono stati eseguiti correttamente, che abbiamo già preso l'intestazione di questo blocco e l'abbiamo combinata con le intestazioni di qualcun altro da altri segmenti della rete. Abbiamo già formato l'intestazione principale di tutta la rete. Dopo di che, i finalizzatori pongono molti segni di spunta sul blocco finale, che combina tutti i calcoli eseguiti.\n\nAttualmente, questa è la situazione dal punto di vista dell'ecosistema eterogeneo multi-chain più implementato ingegneristicamente, che è Polkadot. È l'ecosistema eterogeneo multi-chain più implementato ingegneristicamente, non troppo distante da Ethereum. Mi piacerebbe concentrarmi sul confronto, e se qualcuno è interessato a capire come fluiscono i blocchi di informazioni in Ethereum con le reti L2, può provare a farlo ora. Tornerò su questa questione quando alcuni elementi di Ethereum, in termini di eterogeneità e aspetti multi-chain, saranno completati. Potrebbe richiedere 1-2 anni, e poi possiamo costruire un tale quadro. Tuttavia, possiamo generalmente accettare uno schema con tre fasi principali:\n\n**1. Formazione di un candidato per il blocco delle informazioni:**\n   - In questa fase, viene formato il candidato iniziale per il blocco delle informazioni.\n\n\n**2. Esecuzione di tutti i calcoli, archiviazione dei dati, disponibilità dei dati, ricontrollo con altri nodi, garantendo che tutte le transizioni di stato siano eseguite correttamente secondo algoritmi specifici e memorizzando questi algoritmi nel citadel principale:**\n   - Questa fase coinvolge l'esecuzione effettiva dei calcoli, il salvataggio dei dati su determinati livelli, garantendo la disponibilità dei dati, il ricontrollo con altri nodi per confermare che tutte le transizioni di stato siano conformi agli algoritmi memorizzati da qualche parte nel citadel principale.\n\n\n**3. Finalizzazione, che non ricontrollerà i calcoli ma verificherà le meta-informazioni, come queste meta-informazioni sono memorizzate. Assemblerà quindi il blocco finale, che è lo stato degli stati, e lo rilascerà come un blocco di informazioni comune per l'intera rete multi-chain segmentata:**\n   - La fase finale coinvolge il controllo delle meta-informazioni, la verifica di come queste meta-informazioni sono memorizzate, l'assemblaggio del blocco finale (stato degli stati) e il rilascio come un blocco di informazioni comune per l'intera rete multi-chain segmentata.\n\n\nA questo punto, possiamo dire che le nostre informazioni sono salvate. Sono passate attraverso il cuore, il cuore ha eseguito correttamente il trasferimento dei dati e possiamo già utilizzare i valori in uscita. Alcuni li utilizzeranno per aprire un appartamento acquistato con un contratto intelligente con una serratura intelligente, mentre altri potrebbero mostrare il loro NFT, appena ricevuto per 10 ethers.\n\nIn generale, è approssimativamente così che funziona. Questo conclude la parte teorica. Penso che ci siano volute circa 2 ore e davanti a noi ci sono sessioni pratiche che registrerò nei prossimi mesi. Ci aiuteranno a comprendere i dati osservati dalla finestra della console, le applicazioni decentralizzate, gli esploratori di blocchi, dove capiremo gradualmente come tutti questi numeri e lettere teorici appaiono effettivamente nell'implementazione utilizzando Polkadot come esempio. Inizierò anche ad impegnarmi con le implementazioni a livello L2 utilizzando uno dei framework ben noti per la costruzione di L2. Grazie a tutti coloro che hanno guardato.\n","fileInfo":{"path":"it/learn/world-computer/the-path-of-a-new-block-of-information-in-the-world-computer.md","name":"the-path-of-a-new-block-of-information-in-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}