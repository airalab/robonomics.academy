{"hash":"cc71bf47aafce049dec68b910ec43100bf99e437","data":{"course":{"id":"56fdef08410ceebd90e2d3045f702bbb","title":"Parte 3: Emergência do Computador Mundial","description":"Na terceira parte intitulada \"Emergência do Computador Mundial,\" tentaremos, camada por camada, recriar a implementação de engenharia do computador mundial usando exemplos do Ethereum e Polkadot, como antes.","content":"\nNa terceira parte intitulada \"Emergência do Computador Mundial,\" tentaremos, camada por camada, recriar a implementação de engenharia do computador mundial usando exemplos do Ethereum e Polkadot, como antes.\n\nVamos começar com o Ethereum. O Ethereum começou em 2015 com um estado que pode ser caracterizado como uma combinação do algoritmo de consenso de prova de trabalho, permitindo que o computador mundial exista em um estado descentralizado (como discutido na Parte 2). Além disso, a Máquina Virtual Ethereum (EVM) foi introduzida, servindo como uma máquina computacional completa de Turing. Juntos, esses dois elementos formaram a primeira versão do computador mundial, às vezes referido como um precursor. Dentro deste contexto, aplicativos descentralizados, ou contratos inteligentes, começaram a surgir.\n\nNos próximos 5 anos, o Ethereum viveu uma vida relativamente inalterada, passando por alguns ajustes de engenharia, como um aumento contínuo nos limites de gás, com exceção de eventos como o fork de Xangai. Notavelmente, durante o segundo DEFCON realizado em Xangai, um ataque de negação de serviço explorou uma função na máquina virtual que consumia gás mínimo, mas acionava cálculos significativos na rede Ethereum. Isso levou a um estouro de memória, interrompendo efetivamente um nó Ethereum inteiro. Este incidente destaca os detalhes intrincados que surgem ao lidar com uma solução grande e abstrata como a criação de uma máquina virtual.\n\nAvançando, ocorreu uma mudança significativa por volta do final da década, particularmente em 2020, com o advento do Ethereum 2.0. No entanto, o Ethereum 2.0 agora foi descontinuado, e eu caracterizaria a verdadeira inovação como começando por volta de 2019-2020. Durante este período, houve uma verdadeira inovação tecnológica no Ethereum, avançando para o conceito de Ethereum 2.0. O momento da mudança de engenharia na arquitetura do Ethereum pode ser considerado o evento conhecido como \"a fusão,\" onde as funcionalidades da cadeia de beacons foram combinadas. A fusão marcou uma mudança significativa no paradigma do Ethereum, transicionando para um estado ligeiramente diferente do que estava no quadro. A mudança real de engenharia na arquitetura do Ethereum pode ser associada à \"fusão,\" onde as funcionalidades da cadeia de beacons foram integradas. Para uma história detalhada disso, você pode consultar o site ethereum.org, que fornece um excelente artigo sobre a coexistência do blockchain tradicional do Ethereum com o blockchain paralelo lançado em 2015 e a Máquina Virtual Ethereum.\n\nQuando ocorreu a fusão, testemunhamos uma nova representação arquitetônica, tanto no nível da rede quanto para os nós individuais interagindo com a rede Ethereum. Qual foi a mudança real? Para muitos, a fusão significa a transição do proof-of-work para o proof-of-stake, o que é de fato significativo. Isso implica em aumento de eficiência e ajustes finos, mas ainda é um ajuste relativo a um dos parâmetros. No entanto, a mudança de engenharia interna mais notável para cada cliente de rede foi a divisão. Não havia mais um cliente de rede específico ou uma arquitetura monolítica. Em vez disso, obtivemos dois componentes de um único nó interagindo com a rede Ethereum.\n\nA primeira parte, que eu rotulei como \"cadeia de faróis\" no diagrama, representa essencialmente uma imagem coletiva de todas as inovações que entraram no cliente Ethereum no momento da fusão. A segunda parte é a máquina virtual preservada. No entanto, vale a pena acrescentar algo aqui também. Os diálogos realmente começaram sobre a substituição da máquina virtual, que foi exclusivamente projetada para trabalhar com contratos inteligentes e contratos inteligentes em uma linguagem específica - Solidity. Isso ocorre porque, em 2015, praticamente não havia mais intérpretes para contratos inteligentes em idiomas diferentes de Solidity, e a arquitetura parecia um tanto unilateral do ponto de vista de um programador Ethereum. Você aprende um trecho de JavaScript na forma de Solidity, escreve código de contrato inteligente nele e obtém seu DApp, como Uniswap, por exemplo.\n\nDesde o surgimento de uma arquitetura Ethereum mais complexa, as discussões giraram em torno da ideia de que a máquina virtual, que existia como um elemento um tanto monolítico desde 2015, também pode ser substituída na nova arquitetura. A conversa mudou para substituí-la por algo como WebAssembly (Wasm) ou uma solução mais interessante do ponto de vista da escrita de código para o computador mundial. Você poderia dizer, \"Wasm com um ponto de interrogação.\"\n\nDo ponto de vista da Beacon Chain, ela realmente opera no proof-of-stake, mas o que é mais interessante é a inclusão do Gasper. Isso representa uma modificação das ideias originais sobre Casper. Casper, frequentemente referido como o dispositivo de finalidade do fantasma amigável, foi introduzido, talvez até mesmo tão cedo quanto Defcon 3 ou 4, e talvez até mesmo discutido em Defcon 2 - não me lembro exatamente. Mas na conferência EthCC em Paris, que definitivamente ocorreu em 2018, Vlad Zamfir e Vitalik, de salas diferentes, estavam discutindo o surgimento de Casper como um fantasma amigável, supervisionando os participantes no proof-of-stake e vindo em auxílio da rede quando um nó se comporta mal. A partir dessa ideia de Casper, surge o Gasper. Sem entrar muito na terminologia, o algoritmo de consenso passa por uma mudança, mudando não apenas em termos de simplicidade, mas também se tornando mais complexo, semelhante ao Polkadot. Como mencionei anteriormente, o Polkadot tem dois algoritmos de consenso, Babe e Grandpa. Da mesma forma, com a funcionalidade da Beacon Chain do Ethereum, alcançar consenso e finalidade não é tão instantâneo. Envolve épocas, e a rede opera em um cenário mais complexo, alcançando um estado que já é um tanto dinâmico, não congelado, e essencialmente esculpido em pedra.\n\nO que pode ser adicionado em relação a 2024? Para mim, foi uma observação prolongada e uma tentativa de entender se o Ethereum eventualmente implementaria ou não o sharding. Sharding é a capacidade de existir não com uma única blockchain, mas com várias blockchains dentro de uma rede. Enquanto observava a fusão e o surgimento simultâneo das redes de Camada 2 (L2), surgiram perguntas em minha mente sobre se o sharding realmente se materializaria. O sharding me pareceu interessante devido à sua homogeneidade - ter várias cadeias que são quase idênticas, sem características específicas. Parecia ser uma abordagem interessante, mas não tão flexível quanto uma abordagem heterogênea. Nas redes L2, mesmo há vários anos, eu podia ver a heterogeneidade do Ethereum, sua capacidade de trabalhar com vários tipos de blockchains mais específicas. Eu estava curioso sobre a direção que tomaria - se o sharding, com sua homogeneidade, deslocaria as soluções L2 ou se as soluções L2 com uma abordagem heterogênea saturariam a Beacon Chain e os principais nós da rede Ethereum.\n\nHoje, em 2024, com base em artigos em ethereum.org, parece que o sharding como conceito foi adiado, e o foco está em ajudar várias redes L2 a se integrarem com a Beacon Chain e se alinharem com a funcionalidade da cadeia principal, que agora está dividida em dois elementos na arquitetura da rede Ethereum.\n\nPortanto, sem aprofundar nos detalhes de como as redes L2 são estruturadas - embora vamos abordar isso quando preenchemos a segunda parte do quadro - devemos imaginar que o Ethereum é agora uma espécie de Beacon Chain, um farol, uma estrela guia para inúmeras redes L2. Essas redes L2 podem ter funcionalidades mais específicas, executando sua lógica de acordo com um conjunto de funções individuais. Isso está um pouco alinhado com a ideia de um canivete suíço - não tornando o Ethereum um canivete suíço, mas as redes L2 estão começando a se diferenciar em arquitetura. Elas duplicam a funcionalidade da máquina de computação abstrata do Ethereum, mas a executam com custos de gás mais baixos ou dentro de seu segmento específico. Alguns já estão pensando em ajustar e tornar sua camada L2 mais eficiente, focando em capacidades funcionais específicas. Assim, na minha opinião, estamos testemunhando o surgimento da heterogeneidade no computador mundial que visava ser homogêneo. Além disso, é essencial não esquecer que as aplicações descentralizadas (dApps) ainda existem dentro da blockchain principal, dentro da mesma blockchain que começou em 2015. Isso significa que durante a fusão, durante a transição para o novo estado arquitet��nico, não houve eliminação, não houve apagamento da história anterior. Todas as aplicações descentralizadas e contratos inteligentes subjacentes a essas aplicações continuaram a existir, e continuam a existir hoje, e provavelmente amanhã. Esta é uma questão que exploraremos usando o Polkadot como exemplo, mas ainda há a sensação de que será possível estabelecer uma aplicação descentralizada na Beacon Chain - dApps.\n\nEm resumo, vamos imaginar a implementação de engenharia do Ethereum de hoje como um computador mundial. Temos cada nó de rede consistindo em duas partes. A primeira camada é responsável pela Máquina Virtual Ethereum (EVM), a funcionalidade real da máquina virtual ou máquina completa de Turing, se falarmos em termos teóricos. Talvez vejamos o surgimento de alternativas à máquina virtual projetada em 2015. Essas alternativas provavelmente a superarão em termos de possibilidades de programação mais abstratas do que escrever contratos inteligentes em Solidity. Enquanto isso, os contratos inteligentes em Solidity continuam a se sentir confortáveis. Se você deseja escrever funcionalidades para a cadeia principal do Ethereum sem criar qualquer infraestrutura em cima do Ethereum, sem descarregar quaisquer cálculos para torná-los mais baratos, e assim por diante, as aplicações descentralizadas que voc�� pode escrever como contratos inteligentes ainda podem ser hospedadas na blockchain principal do Ethereum. Ao mesmo tempo, a funcionalidade da Beacon Chain surgiu, separando a lógica de consenso entre validadores do protocolo principal da máquina de computação. Isso permite flexibilidade adicional em como o consenso deve funcionar e como deve ser modificado sem afetar a própria máquina virtual. O exemplo de Xangai e Defcon 2, onde um pequeno erro de opcode causou o desligamento de parte da infraestrutura, sugere que seria bom ter tais funcionalidades complexas separadas em duas partes.\n\nO que é interessante sobre a Beacon Chain? É um algoritmo mais complexo e abrangente para alcançar a sincronização e finalização da rede com a introdução de conceitos como \"época,\" e a presença de um fantasma vivendo dentro da rede.\n\nPor último, o que é importante considerar agora é que o Ethereum está efetivamente colocando um fim à homogeneidade, à ideia de ter cem blockchains idênticas trabalhando com a mesma máquina virtual, onde contratos inteligentes escritos em Solidity podem residir. Em vez disso, vários projetos estão propondo suas próprias arquiteturas ou a mesma máquina virtual levada além dos limites da blockchain principal. Alternativamente, estão tentando construir sua aplicação mais específica, que, no nível da cadeia principal da Beacon Chain, é um contrato inteligente escrito em Solidity. Esta é a representação atual do Ethereum, que não se tornou Ethereum 2.0. Continua sendo o mesmo Ethereum - um projeto que uma vez começou com prova de trabalho + máquina completa de Turing, transformando-se nesta arquitetura.\n\nAgora, vamos dar uma olhada em como o Polkadot surgiu e evoluiu nos últimos 5 anos. O Polkadot surgiu cinco anos após o Ethereum, nascido da equipe que desenvolveu um dos melhores clientes para o Ethereum - Parity. Muitos podem se lembrar de seu cliente web, que, comparado ao Geth e outras implementações, provavelmente era muito mais agradável de trabalhar, pelo menos pela experiência pessoal e a experiência dos colegas.\n\nEm segundo lugar, Polkadot foi, na minha opinião, uma extensão das ideias que Gavin Wood queria incorporar no desenvolvimento do Ethereum. Consequentemente, pode-se dizer que o Ethereum, em algum momento, se dividiu em dois conceitos.\nO que tínhamos quando o Polkadot foi lançado? A cadeia de retransmissão foi lançada. Curiosamente, certo? Corrente de farol e corrente de relé. O que a cadeia de retransmissão representa? Inicialmente, não havia possibilidade de colocar um aplicativo descentralizado lá, escrever um contrato inteligente para ele ou fazer upload de seu código no WASM ou no Solidity. Nada disso estava disponível na época do primeiro bloco ou nos primeiros dias de existência da cadeia de retransmissão Polkadot. Não houve como adicionar seu tempo de execução, sobre o qual falaremos em breve, e não foi baseado em prova de aposta; em vez disso, usou prova de autoridade. Isso permitiu que certos nós lançados pelos desenvolvedores do Polkadot sobrevivessem aos primeiros meses ou semanas, enquanto ataques poderiam ser lançados na cadeia ou se ela se comportasse incorretamente. No entanto, isso foi rapidamente alterado e a cadeia de retransmissão passou para prova de aposta.\n\nNo final, após alguns meses da existência da cadeia de retransmissão sem nenhuma funcionalidade de aplicativo descentralizado, sem a capacidade de conectar sua parachain ou rede L2, sem capacidades de usuário, a rede fez a transição de um estado de autoridade para prova de participação. Isso deu aos desenvolvedores a capacidade de fazer upload de seus runtimes.\n\nNeste ponto, também é interessante discutir as diferenças entre o Ethereum de hoje e como a parte central do Polkadot é estruturada. Do ponto de vista do coração, que já discutimos, a imagem será absolutamente a mesma não apenas para o Ethereum e o Polkadot, mas para qualquer projeto que queira ser apresentado como uma máquina de computação abstrata. No entanto, do ponto de vista de engenharia e arquitetura, é fascinante observar a Beacon Chain & Relay Chain. Aqui, temos uma máquina virtual, que foi herdada desde 2015, mas estão sendo propostas alternativas. Na cadeia de retransmissão, há a capacidade de fazer upload do seu runtime. O runtime é, na verdade, sua máquina virtual. Por exemplo, algumas parachains emulam completamente a Máquina Virtual Ethereum. É escrito como um runtime, o que significa que você pode essencialmente fazer upload de um análogo da Máquina Virtual Ethereum para o nível de parachain no Polkadot ou escrever lógica mais específica que funcione com quatro ou cinco funções. Lembre-se da parte um sobre as ideias - você pode escrever sua canivete suíço, mas não será necessário criar toda a infraestrutura. Você pode implementar funcionalidades específicas com certas funções no nível de runtime, colocá-las na cadeia de retransmissão do Polkadot e a imutabilidade deste runtime será garantida pelos validadores do Polkadot.\n\nO que acontece a seguir? Ao longo de cerca de um ano, uma camada de parachains começa a se formar em torno da cadeia de retransmissão. Em termos de implementação do Ethereum, você poderia dizer que as redes L2 são bastante semelhantes às parachains. No entanto, há uma distinção interessante entre redes cruzadas que eu acho fascinante no Polkadot, e estou tentando entender melhor como isso se desenvolverá - ou seja, a segunda camada de validação e verificações de disponibilidade de dados. Após alguns anos, o Polkadot assume uma forma como esta. Não é apenas uma cadeia de retransmissão onde os validadores de prova de participação protegem o tempo de execução das futuras parachains; uma camada adicional e crucial de validação de dados e verificações de disponibilidade emerge das parachains.\n\nAo olhar para este diagrama, tente notar as analogias que surgem e as diferenças nos detalhes de implementação de engenharia. Então, o que isso representa e como esse esquema se compara com o Ethereum? Temos um projeto L2, neste caso, com o Polkadot, é uma parachain. Uma parachain também gera blocos de informações, que então vão para a cadeia de retransmissão para serem combinados e liberar um bloco de cadeia de retransmissão como a soma de todos os cabeçalhos, cabeçalhos e mais cabeçalhos. A parachain coleta transações em um bloco usando coletores, que não estão envolvidos na validação. Eles não apostam nada na cadeia de retransmissão; eles apenas usam o tempo de execução, que está na cadeia de retransmissão. Eles o buscam, aplicam às transações, realizam transições de estado necessárias, formam um bloco e, crucialmente, fornecem prova de validade - um carimbo contendo provas criptográficas de que o coletor montou corretamente o bloco. Essas informações vão para o anel de validação externo da cadeia de retransmissão. Neste anel, existem validadores internos do Polkadot - coletores de parachain. Novamente, eles não apostam nada diretamente do ponto de vista da cadeia de retransmissão. As implementações de parachain às vezes introduzem seu consenso entre coletores, e algumas não. Por exemplo, no Robonomics, implementando uma parachain, encontramos esse paradigma mais interessante, menos oneroso, e torna a rede mais simples, mantendo-se funcionalmente substancial. Qualquer coletor, sem chegar a um consenso com ninguém - verificado por nós - pode propor um bloco e alguma prova para a camada externa. É exatamente por isso que os blocos são propostos, as provas de validade da montagem do bloco são oferecidas, e há um anel externo. Não precisamos de nenhum consenso dos validadores de parachain. Qualquer um pode gerar um bloco e enviá-lo, e se este nó do coletor enviar informações incorretas para os validadores de parachain no anel externo, o validador neste nível o rejeitará. Não passará para a parte central. Mas digamos que o bloco tenha sido fornecido corretamente pelo coletor. Nossas transações entraram; o coletor as calculou, aplicando o tempo de execução armazenado na cadeia de retransmissão, executou todas as transições de estado, reuniu alguma prova de validade - validade do bloco montado - e passou para o anel externo da cadeia de retransmissão. Aqui, a cada época, que também faz parte da finalização, cada época tem validadores da cadeia de retransmissão divergindo para as parachains. Alguns deles permanecem no centro, e os outros vão para as parachains. Seu número varia de 16 a 64 validadores, e essa figura, acredito, mudará na especificação - em alguns lugares mais, em outros menos. No entanto, os validadores de parachain re-verificam as informações de um grupo selecionado de validadores sobre tudo o que vem do coletor estar correto, que o trabalho foi feito de acordo com o tempo de execução, e que a prova de validade é realmente válida. O segmento selecionado de validadores da cadeia de retransmissão que já têm algo apostado responde, ou melhor, chilreiam entre si. Eles respondem ao produtor principal de bloco escolhido da parachain, por assim dizer, dizendo, \"Sim, concordamos. Não há problemas. Você pode levá-lo por todo o anel externo internamente.\"\n\nE assim, quase todas as informações formadas nos coletores de parachain, com verificação no anel externo, entram no interno. A parte inferior, não que esteja fisicamente no fundo, ainda constitui o anel externo - disponibilidade de dados. Os dados começam a ser verificados nesta fase, o que significa que no anel externo, não apenas a correção da montagem do bloco é verificada, mas o processo de preparação para distribuição dentro da rede Polkadot começa, garantindo que as informações do bloco não sejam perdidas no futuro. Aqui, precisamente, é o que mencionei na segunda parte sobre chunks, como CD RW. Nesta fase de preparação do bloco para transferência para o anel interno, a camada de disponibilidade de dados é formada como um serviço, algo que atualmente também é tentado por alguns projetos no Ethereum. Alguns projetos colocam informações redundantes adicionais diretamente em contratos inteligentes, necessárias para verificar o que está acontecendo na camada L2 e, se necessário, punir ou penalizar aqueles que fizeram incorretamente. É impossível superar o anel externo sem distribuir informações de bloco e sem rechecar dezenas de nós com apostas feitas com base na suposição de que o tempo de execução deve funcionar corretamente.\n\nAssim, as informações que passaram pelo anel externo já são bastante confiáveis, provavelmente sim, você pode dizer isso, e no anel interno, o trabalho é feito principalmente não com blocos de parachain, mas seus cabeçalhos de bloco são coletados em um grande cabeçalho. Ou seja, de muitos cabeçalhos, um cabeçalho de um bloco de cadeia de retransmissão é montado - um mecanismo de ligação em Shared Security, como mencionado no Polkadot, que garante a segurança das parachains. Poderíamos dizer que as parachains são validadas e alcançam um estado em que o serviço existe de forma distribuída descentralizada no anel externo. No anel interno, as informações que entraram tentam se unir em um hiperbloco, que deve ligar tudo precisamente. Não há cálculos acontecendo lá; não há recalculo de absolutamente tudo. A montagem do bloco final acontece, por assim dizer, na iteração atual do computador mundial, para colocar um ponto na questão de se a transação passou em uma parachain específica. Devemos montar um hiperbloco que contenha não todas as informações das parachains, mas reúna todos os cabeçalhos verificados no anel externo das parachains em um grande bloco. E assim, nosso computador mundial no Polkadot opera.\n\nVamos dar mais uma olhada nesses dois esquemas juntos: cadeia de retransmissão, cadeia de farol, tempo de execução, garantido por prova de participação, onde alguém aposta seus fundos para validar que sempre executarão seu trabalho corretamente. Existe uma máquina virtual onde você também pode apostar seus fundos e, se você realizar qualquer computação ou transição de estado que não esteja de acordo com a especificação da Máquina Virtual Ethereum, você será penalizado.\n\nNo Polkadot, há uma camada externa adicional, que parece ser uma das principais vantagens, tais benefícios agradáveis da implementação de engenharia que, na minha opinião, deveriam estar presentes aqui. Deveria aparecer entre as redes L2 e a cadeia de farol, que existe no Ethereum. A propósito, alguns dizem que o termo \"cadeia de farol\" está caindo em desuso novamente e é mal compreendido, mas eu realmente gosto de usá-lo em analogia com a \"cadeia de retransmissão\", um termo do roteiro do Ethereum.\n\nNo Polkadot existe uma camada externa que permite, ou melhor, acho que foi inventada para resolver muitos problemas que surgem quando você tem L2 ou um conjunto de blockchains que precisam estar conectados. Nesta camada é implementado um mecanismo de engenharia de distribuição de informações para disponibilizá-las em uma rede descentralizada. Algoritmos adicionais são introduzidos para verificar não apenas a validade, mas também a disponibilidade de informações pelos validadores. Além disso, há um mecanismo para atribuir aleatoriamente uma parte dos validadores Polkadot a parachains específicos a cada época. Portanto, nem os mesmos validadores servem parachains em todas as épocas; eles são embaralhados e enviados para diferentes parachains em cada época. Ao transferir um bloco do anel externo para o interno, os validadores são verificados novamente ao longo do caminho e coordenados com aqueles atribuídos ao parachain. Atualmente esse processo não existe, mas acho que em algum momento aparecerá.\nE talvez o último ponto seja sobre os agrupadores, que hoje são implementados de maneira bastante interessante nos parachains. Podem ser consensuais ou existir sem consenso, mas, na verdade, funciona. Quanto às questões em redes L2 com sequenciadores descentralizados ou como os blocos serão gerados e verificados antes de se instalarem na máquina virtual - estas são questões separadas para a implementação do Ethereum em formato heterogêneo. Neste dia, está muito bem implementado em Polkadot, na minha opinião. No entanto, isso não significa que Polkadot esteja à frente de todo o planeta e nunca alcançará Ethereum. Embora seja esta arquitetura que me atrai a continuar trabalhando e esperando que Polkadot continue a se desenvolver bem em termos de tecnologias porque não vi nada parecido em todos os aspectos conectados.\n\nE talvez mais uma história interessante nesta parte da palestra: até agora, mal podemos imaginar mensagens apropriadas entre redes L2 na Ethereum. Talvez eu tenha perdido algo nos artigos, mas quando não se tem um anel externo e questões como coletores, paravalidadores e serviços de disponibilidade de dados não estão resolvidas, pensar em como duas camadas L2 podem se comunicar é desafiador. No entanto, no Polkadot, isso existe. Mesmo horizontalmente, através da cadeia de retransmissão, ou seja, diretamente, alguém pode enviar uma transação com segurança de uma paracadeia para outra, sem confiar em pontes entre essas duas paracadeias. Esta é outra funcionalidade crucial que provavelmente precisará ser implementada no nível de conexão de redes L2. Os contratos inteligentes na Ethereum se comunicam bem. Criamos muitas cadeias de contratos inteligentes vinculados, onde um aciona o outro. Com isso, não há problema. Mas quando dizemos que quase todas as aplicações estão migrando para a camada L2 em uma rede heterogênea, ouço dizer que se você mora em uma área específica, não conseguirá sair. Isso não acontece no nível das paracadeias e na implementação no Polkadot. Ambas as arquiteturas valem a pena ser observadas, pois, na minha opinião, a implementação de engenharia segue o caminho principal de se tornar um computador global. Elas diferem ligeiramente, mas há muitas semelhanças. Há uma enorme quantidade de trabalho de engenharia em todos os lugares. Como vemos, a civilização humana, na forma de uma multidão de pesquisadores, engenheiros e desenvolvedores em crescimento com recursos significativos para o desenvolvimento futuro, está se movendo aproximadamente na mesma direção desde o menor estágio inicial até provavelmente algum futuro estabelecimento do computador mundial, todos nos mesmos trilhos.\n","fileInfo":{"path":"pt/learn/world-computer/emergence-of-the-world-computer.md","name":"emergence-of-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}