{"hash":"b245a40217fbced1639aa527710a032ddca236bc","data":{"course":{"id":"6b896af0eae8a6595fbff3feeaaf007c","title":"Parte 4: O Caminho de um Novo Bloco de Informações no Computador Mundial","description":"A quarta e última parte de nossa palestra é \"O Computador Mundial em Sua Casa.\" Depois disso, começarei a gravar screencasts para a parte prática das sessões.","content":"\nA quarta e última parte de nossa palestra é \"O Computador Mundial em Sua Casa.\" Depois disso, começarei a gravar screencasts para a parte prática das sessões.\n\nAgora vamos tentar resumir quase toda a teoria que cobrimos até agora em termos de um processo. O processo que descreve o caminho de um bloco de informações no computador mundial. Vamos começar novamente retornando ao tema do web3 e ao conceito de blockchain. A frase \"bloco\" ou \"bloco de informações\" pode ser considerada idêntica ao se afastar dos últimos 10 anos e adotar uma teoria mais geral, como explorado nas partes anteriores das palestras. O conceito de um \"bloco de informações\" se alinha com o web3, mas não necessariamente com blockchain. Mesmo sem projetos de criptomoeda, precisamos entender que ao formar a teoria do computador mundial sem fazer referência à formação de blocos de informações, atualmente é desafiador imaginar outros modelos. Portanto, consideraremos o caminho de um bloco de informações em todo o computador mundial, não porque seja blockchain, mas porque, por enquanto, não há outras maneiras de conceituar a existência do computador mundial al��m de processar informações em porções específicas.\n\nBloco de informações = bloco no web3, mas sem blockchain e sem influência de qualquer projeto de criptomoeda. Atualmente, devemos considerar a formação de blocos de informações ao discutir a teoria do computador mundial. Agora, vamos passar para o primeiro ponto. Tentei encontrar analogias próximas da vida cotidiana para ajudar a ilustrar o caminho de um bloco de informações no computador mundial. A analogia que escolhi é o movimento de um ônibus em uma rota. Nosso primeiro ponto de encontro é a estação de ônibus.\n\nMarquei transações em rosa como pequenos pontos. Vamos imaginar uma parada de ônibus típica onde as pessoas se reúnem, esperando por um ônibus que opera em um horário. Se não considerarmos a agitação das grandes cidades, onde os ônibus sempre estão atrasados, todos no mundo geralmente sabem que o trem da vila A para a vila B sempre chega por volta das 7h15. As transações que os usuários desejam enviar para o computador mundial se reúnem em uma determinada parada de ônibus e esperam o ônibus chegar.\n\nAssim é como nosso bloco é formado. Imagine: o ônibus chega, e cada pessoa começa a embarcar um por um, ocupando seus assentos. O ônibus então segue seu caminho. No nosso caso, o bloco de informações supera a primeira fronteira. Nossas transações, de alguma forma, se estabeleceram no ônibus e superaram a barreira inicial. Estarei usando terminologia principalmente do Polkadot, e a terceira parte deveria ter melhor explicado o conceito do computador mundial na comparação entre Ethereum e Polkadot. Minha opinião pessoal, e provavelmente a maioria dos engenheiros concordaria hoje, é que a representação de um computador mundial heterogêneo e multicêntrico é melhor implementada no Polkadot. No entanto, ainda passaremos pelos termos herdados do Ethereum, mas no final desta parte da palestra.\n\nQual é a linha que separa o ponto de ônibus do movimento adicional do ônibus? Essa linha representa os coletores da rede - participantes nos nós da rede que coletam transações. Você pode pensar em um coletor não como um motorista de ônibus, mas como um controlador que fica no ponto de ônibus. Em outras palavras, esse controlador verifica se você tem um bilhete quando entra no ônibus. Ele não verifica novamente no banco de dados quão válido é o bilhete, mas olha para os parâmetros básicos do bilhete e verifica se tudo parece bem. Na realidade, os coletores realizam quase todos os cálculos necessários, verificando o número do bilhete e outros dados, mas não são obrigados a garantir que a verificação seja feita corretamente. Portanto, os coletores são controladores que permanecem no ponto de ônibus, garantindo principalmente o embarque de passageiros, a ocupação de assentos e o envio do ônibus ao longo da rota.\n\nAlém da fronteira desenhada, entramos na primeira área de validação onde estão localizados os paravalidadores. Estes são validadores de todo o ecossistema, de toda a rede, especificamente designados por um certo tempo para verificar cada transação e assim realizar cálculos reais no computador mundial. Nosso bloco de informações ainda não totalmente formado é marcado com uma linha tracejada. Ainda é um bloco de informações candidato, pois não passou por nenhuma verificação real. O coletor, que coletou o bloco de informações e verificou as transações na entrada, não participa de forma alguma na segurança cibernética das computações realizadas. Sua tarefa é apenas acomodar todas as transações e formar o primeiro bloco. Nesta fase, a transformação de um candidato em um bloco real de informações começa.\n\nDividi em três partes, mas esqueci mais uma. Vamos considerar quatro partes deste bloco candidato. A parte superior, conhecida pelos usuários de várias aplicações web3 como o cabeçalho ou cabeçalho de bloco, é a quintessência, a peça de informação mais popular circulando e refletida do explorador de blocos para os clientes de console de todos os nós de mineração, staking, e assim por diante. O cabeçalho é um elemento-chave do bloco, mas é praticamente formado na última etapa neste ponto.\n\nPrimeiramente, temos nossas solicitações reais para transições de estado ou computações. Há uma lista de mudanças que precisam ser feitas: converter A para A', B para B', C para C', aplicando um conjunto de algoritmos a eles. Para isso, agora construiremos imediatamente outra fronteira e iremos além dela para realizar esta parte do trabalho, e então apenas prosseguiremos além dela. Já na fase de preparação do bloco, temos que atravessar a segunda fronteira dentro do computador mundial para ir aos algoritmos que precisam ser aplicados para preparar o bloco. Como mencionei antes, teoricamente, o controlador no ponto de ônibus aqui faz o mesmo, mas eu não daria muita atenção a isso. A fase de preparação do bloco, especialmente quando falamos de exemplos simultaneamente do Polkadot e do Ethereum como um computador mundial, eles diferem ligeiramente e nos mostram a insignificância das verificações nesta fase, porque é precisamente na segunda etapa, após passar a primeira fronteira e receber o bloco de informações dos coletores, que os cálculos dignos de atenção deste computador mundial começam.\n\n\nPara realizar esses cálculos, o validador, nesta fase, só pode fazê-lo recorrendo à cadeia de retransmissão, ao banco de dados central, e retirando de lá os algoritmos do tempo de execução. No caso do Ethereum, eram as mesmas máquinas virtuais no conceito arquitetônico anterior, que poderiam ser aplicadas, então não havia necessidade de ir a nenhum lugar. Quase todos os nós tinham uma cópia completa dos algoritmos que poderiam ser aplicados. Mas em termos de uma rede heterogênea, onde cada segmento ou cada cadeia individual pode ter seu próprio conjunto de algoritmos, um validador, antes de realmente executar todas as transições, cálculos obtidos na forma de um bloco candidato do coletor, deve consultar. Deve consultar a cadeia de retransmissão, consultar o blockchain principal na rede e retirar de lá os algoritmos necessários, aplicá-los e realizar transições de estado.\n\nDurante a execução dos cálculos, uma árvore de Merkle é formada simultaneamente, e não vamos nos deter nisso porque as árvores de Merkle não são tão complicadas do ponto de vista da ciência da computação. Ainda assim, percebo que para entender como aplicá-las em engenharia e na arquitetura de um projeto, como elas são aplicadas, não apenas lendo na Wikipedia, você precisa quebrar um pouco a cabeça, imaginar exemplos. Neste exemplo, não vamos nos aprofundar muito, mas acho que para aqueles que já estão familiarizados com algumas definições básicas, leram sobre árvores de Merkle, ficará um pouco mais claro sobre como e em que momentos outra árvore de Merkle é montada. A árvore de Merkle é formada quando realmente realizamos cálculos e valores de saída aparecem. Esses valores de saída são empacotados em um formato de árvore binária, então a adição é realizada entre eles na linguagem da ciência da computação, e o nó superior atinge o cabeçalho. Vamos denotá-lo com uma letra maiúscula \"H.\" É um aspecto pequeno e agradável considerar tais esquemas.\n\nNeste esquema, podemos observar como o cabeçalho do bloco está realmente relacionado com os cálculos realizados internamente. Vamos olhar novamente - nosso bloco candidato veio do coletor. Há um conjunto de transações que precisam ser executadas, realizar cálculos. O validador passou por outra fronteira interna, mais uma, atrás dos algoritmos, os aplicou e registrou todos os resultados no nível mais baixo da árvore de Merkle. Os outros nós são essencialmente sistêmicos. Eles não vêm de nenhum dado; eles não vêm de lugar nenhum. No segundo nível, o nó não vem de nenhuma informação. Ele é obtido somando valores nesses dois nós, e quando subimos com você, obtemos apenas a raiz desta árvore, que é suficiente para proteger todos os valores de saída. Não obteremos o mesmo cabeçalho se alterarmos qualquer um desses cálculos. E esta é uma das características mágicas e simples, como o armazenamento orientado a hash, de como podemos proteger um bloco inteiro de informações falando apenas sobre um cabeçalho. Portanto, os cabeçalhos são tão importantes e desempenham um papel fundamental mesmo em arquiteturas quando fazemos a transição de uma cadeia ou de uma máquina virtual para muitas combinadas na rede. É suficiente para nós garantir a segurança de armazenar cabeçalhos para ter certeza de que todas as transações que foram executadas na fase de preparação do bloco foram executadas corretamente e não podem ser substituídas.\n\nE um campo ainda está vazio. No processo de preparação do bloco de informações, é o campo do autor, ou seja, o validador que realmente realizou todas as alterações, preparou a árvore de Merkle e registrou o cabeçalho. Como estamos considerando um exemplo com o ônibus se movendo ao longo da rota a partir da parada, vamos chamar o validador de \"controlador\" que entra no ônibus, passa por cada assento, se aproxima de cada pessoa, verifica o que está escrito em seus bilhetes, faz alguma marca, valida e, consequentemente, coloca sua assinatura. O controlador, por exemplo, número 134, o que significa, naturalmente, que cada validador tem um identificador único, seu endereço, e também o renomeamos de forma única aqui.\n\nE parece que neste ponto poderíamos ter sombreado e tornado nossos limites de bloco mais ousados, mas não, e esta é uma das mudanças interessantes que ocorreram nos últimos 5 anos em termos de ecossistemas descentralizados, ou seja, a mudança do proof of work. Quando os validadores da rede, naquela época mineradores, nunca precisavam coordenar nada entre si. Você produzia um bloco e o enviava para a rede e seguia em frente. Na verdade, não era um consenso de consentimento acordado. Era um consenso de acordo óbvio com o fato que havia ocorrido. O que é interessante nas mudanças quando a arquitetura se torna mais complexa, e nos aproximamos de um computador virtual real, é que em cada estágio, a conectividade dos participantes que garantem a segurança e a produção de blocos aumentou. Porque, na verdade, ninguém que arrisca sua participação, aquele que garante essa segurança e deseja ganhar processando suas transações, tem algo a perder, ao contrário do proof of work. No proof of work, você comprou o equipamento, sim, investiu dinheiro nele, gastou eletricidade, mas na verdade não há proteção contra o fato de que você pode atacar a rede com seu poder, o mesmo ataque de 51%, onde alguém com muitos mineradores pode tentar reescrever a cadeia.\n\nAgora estamos falando sobre a prova de participação, onde um depósito já foi feito, e se você fizer algo errado, uma parte será retirada dele, como uma penalidade. Todos os nós, absolutamente, em todas as arquiteturas que atualmente observo, mecanismos para mensagens entre validadores começaram a aparecer rapidamente na fase de preparação do bloco. No Polkadot, não é diferente. Qualquer validador de uma parachain separada que coleta um bloco conhece os endereços ou já estabeleceu contato com outros 15-63 validadores que estão com você nesta época, em algum período temporário, como validadores, e cada um deles aleatoriamente se torna um produtor de bloco em algum momento. Mas ser designado como produtor não nega um componente muito importante deste processo. Você não para de interagir com os outros participantes. Sempre há um grupo de validadores designados para uma época específica, para um determinado intervalo de tempo, para validar uma parachain específica ou segmento do computador mundial. Independentemente de você ser um validador-controlador especificamente designado para produzir o próximo bloco no computador mundial deste segmento, você ainda mantém contato com os outros validadores e tem contato constante com eles.\n\nPor que esse contato constante é necessário? Acontece que é bastante simples. Não queremos, ao nos movermos para a parte interna, ter medo ou preocupação de que tenhamos realizado alguma das operações incorretamente. Por mais surpreendente que possa parecer, é benéfico para qualquer validador, antes de prosseguir, primeiro recorrer aos seus colegas designados para validação e pedir a eles para verificar novamente os cálculos. Essa verificação é informal, então mesmo que não usemos nenhum registro em um banco de dados imutável de solicitações de verificação e os resultados dessa verificação, o controlador designado, após falar com o grupo de validadores, ainda coleta respostas adicionais de todos os validadores designados para essa paracadeia ou segmento de rede. Juntamente com confirmações adicionais, o controlador avança para a próxima etapa. Mas mesmo aqui, não é tão simples. Nesta etapa, outro processo precisa ser realizado. É importante notar que nesta etapa, nosso bloco de informações ainda é um bloco candidato, e o acerto de informações já está ocorrendo no armazenamento. Nem no final, nem depois de termos criado e selado o bloco e o anexado com um arquivador na parte final, ou seja, aqui, nesta parte intermediária onde todos os cálculos são realmente realizados, as informações são salvas no armazenamento. Portanto, nosso controlador, além de falar com seus colegas, também garante o armazenamento de dados em algum armazenamento, o que também é bastante metafísico porque no momento em que você se comunica com outros validadores, esse armazenamento é preenchido. Como isso é verificado? Precisaremos avançar para a próxima etapa.\n\nEm resumo, para completar a parte do meio, vamos olhar novamente. Ainda temos apenas um bloco candidato no início. Sim, todas as transações são calculadas aproximadamente em algum lugar no ponto de ônibus, todos já ocuparam seus assentos de acordo com seus bilhetes. Passamos a primeira fronteira, que é essencialmente o contato direto estabelecido entre validadores e coletores de blocos. No Ethereum e no Polkadot, esses esquemas são ligeiramente diferentes agora. Mas tudo o que acontece no lado esquerdo no início não fornece cibersegurança para dados e cálculos. É apenas preparação. Uma vez que passamos e entramos no ambiente da atenção dos validadores, o trabalho com o bloco de informações no computador mundial começa. Um validador selecionado aleatoriamente, em nosso caso, com uma rota de ônibus - um controlador, na verdade passa por cada um dos assentos, verifica o bilhete, verifica e realiza todos os cálculos que foram feitos, reúne todas as informações em uma árvore. O nó raiz resultante desta árvore se torna o cabeçalho do bloco proposto. O validador que realmente realiza todos os cálculos com este bloco de informações se comunica com os outros participantes que desempenham uma função semelhante para a mesma rota em um intervalo de tempo indefinido. E enquanto se comunica com eles e pedindo-lhes para verificar todos os cálculos, na verdade estamos preenchendo um certo armazenamento de dados na rede. Não é um armazenamento físico específico; não há um endereço IP específico, nenhum disco rígido específico no qual todos carregam através de algum esquema de VPN ou login e senha, é claro que não. No processo de comunicação com outros validadores, os dados permanecem em suas máquinas locais, e esses dados participarão posteriormente da transformação desse candidato em um novo bloco de informações. Na essência, o bloco selado que será liquidado na cadeia de retransmissão é coletado. Montamos um bloco. Todos os metadados em torno dos cálculos já estão preenchidos, o que significa que podemos tentar avançar para a próxima fronteira.\n\nNeste momento, vamos aprofundar na passagem da próxima fronteira. O aspecto mais crucial na fase final torna-se o cabeçalho do bloco. Estamos menos preocupados com a execução de cálculos; podemos simplificar nossa perspectiva aqui, já que os cálculos podem variar com base na arquitetura, seja Ethereum ou Polkadot. O ponto chave é que, na fase intermediária, a partir do que observo na teoria e prática da implementação do conceito de computador mundial, a maioria dos cálculos acontece em um nível intermediário. O último nível permanece apenas para executar verificações essenciais. Quase todas essas verificações em uma arquitetura multi-chain estão relacionadas à concatenação ou fusão de cabeçalhos de bloco em um só bloco.\n\n\nNa parte final de nossa jornada, o elemento mais importante no bloco de informações do computador mundial torna-se a pedra angular - o cabeçalho. O segundo componente é mais sobre meta-informação. Se o cabeçalho é o resultado real de todos os cálculos, a meta-informação adicional transmitida consiste em recibos e assinaturas dos validadores que participaram da fase intermediária desse processo. Na fase final, podemos visualizar a imagem completa apenas como a montagem da mesma árvore, não como uma lista de transações. Na parte final da cadeia de retransmissão, o aspecto crucial é a montagem de cabeçalhos de muitos processos semelhantes, mas ligados a diferentes segmentos do computador mundial, diferentes parachains.\n\nCada parachain, cada conjunto de validadores - discutimos um exemplo, mas na realidade, tais preparações de bloco para parachains acontecem 30-40 vezes. O número de slots de parachain ou o número de redes L2 no Ethereum resultará em um número semelhante de processos com uma arquitetura semelhante. No entanto, na fase final, veremos uma imagem aproximadamente idêntica em todos os lugares - como o cabeçalho do bloco será formado a partir de uma multidão de cabeçalhos de outros blocos. Neste processo, precisamos introduzir mais uma entidade e voltar através da fronteira para a segunda fase.\n\nFinalizadores. Na verdade, eles também são validadores, mas validadores da cadeia de retransmissão. Na arquitetura Polkadot, temos mil validadores divididos em dois grupos. O primeiro, um grupo muito pequeno, é responsável apenas pela formação do cabeçalho do bloco e um novo bloco composto pelos cabeçalhos dos blocos do Estado dos Estados. O segundo grupo - validadores de parachain - é ainda dividido em muitos subgrupos, mas este grupo é chamado de validadores de parachain. Nas redes L2 acima do Ethereum, essa história eventualmente ganhará mais compreensão, mais denominadores. Por enquanto, vamos nos concentrar na arquitetura Polkadot. Finalizadores, além de verificar um conjunto adicional de meta-informações e re-verificar um validador com um ID específico, escolhido aleatoriamente para gerar este bloco de todos os blocos, também ajudam a re-verificar as meta-informações, verificar e montar todos os cabeçalhos em um só. É um pouco complexo, sim, se olharmos para isso a partir da perspectiva da montagem da árvore.\n\nAlém disso, na arquitetura do Polkadot e no Ethereum com as últimas mudanças, ocorre uma verificação de disponibilidade de dados. Para isso, os finalizadores visitam os validadores de parachain e tentam solicitar informações reais sobre cada bloco armazenado na rede. Se eles receberem dados de pelo menos 1/3 dos validadores, usando tecnologia que permite o armazenamento redundante de informações, e posteriormente, se alguém perder, um, dois ou três validadores ainda podem restaurá-lo, há um limite crítico em 1/3. Se 1/3 dos nós responderem e disserem que temos dados sobre o bloco sendo produzido, os finalizadores informam ao bloco que ele já é um bloco de informação totalmente formado, que todos os cálculos foram feitos corretamente, que já pegamos o cabeçalho deste bloco e o combinamos com cabeçalhos de outras partes da rede. Já formamos o cabeçalho principal de toda a rede. Depois disso, os finalizadores colocam muitas marcas de verificação no bloco final, que combina todos os cálculos realizados.\n\nAtualmente, esta é a situação do ponto de vista do ecossistema heterogêneo de várias cadeias mais implementado em termos de engenharia, que é o Polkadot. É o ecossistema heterogêneo de várias cadeias mais implementado em termos de engenharia, não muito distante do Ethereum. Gostaria de focar na comparação, e se alguém estiver interessado em entender como os blocos de informação fluem no Ethereum com redes L2, você pode tentar fazer isso agora. Voltarei a esta questão quando alguns elementos do Ethereum, em termos de heterogeneidade e aspectos de várias cadeias, estiverem concluídos. Pode levar 1-2 anos, e então podemos construir tal imagem. No entanto, podemos geralmente aceitar um esquema com três estágios principais:\n\n**1. Formação de um candidato para o bloco de informações:**\n   - Nesta etapa, o candidato inicial para o bloco de informações é formado.\n\n\n**2. Execução de todos os cálculos, armazenamento de dados, disponibilidade de dados, rechecagem com outros nós, garantindo que todas as transições de estado sejam realizadas corretamente de acordo com algoritmos específicos e armazenando esses algoritmos na cidadela principal:**\n   - Esta etapa envolve a execução real de cálculos, salvando dados em camadas específicas, garantindo a disponibilidade de dados, rechecando com outros nós para confirmar que todas as transições de estado estão de acordo com algoritmos armazenados em algum lugar na cidadela principal.\n\n\n**3. Finalização, que não rechecará os cálculos, mas verificará as meta-informações, como essas meta-informações são armazenadas. Em seguida, montará o bloco final, que é o estado dos estados, e o liberará como um bloco de informações comum para toda a rede multi-cadeia segmentada:**\n   - A etapa final envolve a verificação das meta-informações, verificando como essas meta-informações são armazenadas, montando o bloco final (estado dos estados) e liberando-o como um bloco de informações comum para toda a rede multi-cadeia segmentada.\n\n\nNeste ponto, podemos dizer que nossas informações estão salvas. Elas passaram pelo coração, o coração executou sua transferência de dados corretamente e já podemos usar os valores de saída. Alguns os usarão para abrir um apartamento comprado com um contrato inteligente com uma fechadura inteligente, enquanto outros podem exibir seu NFT, acabado de receber por 10 ethers.\n\nEm geral, é mais ou menos assim que funciona. Isso conclui a parte teórica. Acredito que tenha levado cerca de 2 horas e, à nossa frente, estão as sessões práticas que estarei gravando ao longo dos próximos meses. Elas nos ajudarão a entender os dados observados na janela do console, aplicações descentralizadas, exploradores de blocos, onde gradualmente entenderemos como todos esses números e letras teóricos realmente se parecem na implementação usando o Polkadot como exemplo. Também começarei a colocar a mão na massa com implementações no nível L2 usando um dos frameworks conhecidos para construir L2. Obrigado a todos que estiveram assistindo.\n","fileInfo":{"path":"pt/learn/world-computer/the-path-of-a-new-block-of-information-in-the-world-computer.md","name":"the-path-of-a-new-block-of-information-in-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}