{"hash":"76c8f6c333fd43be28237b9e09f4e90eec13e11a","data":{"course":{"id":"075f722d4d78cf4509bdd3078ccd5312","title":"第4部分：信息块在世界计算机中的路径","description":"我们讲座的第四部分也是最后一部分是“您家中的世界计算机”。在此之后，我将开始录制实践部分的屏幕录像。","content":"\n我们讲座的第四部分也是最后一部分是“您家中的世界计算机”。在此之后，我将开始录制实践部分的屏幕录像。\n\n现在我们将尝试总结迄今为止我们所涵盖的几乎所有理论，以一个过程的术语描述。这个过程描述了信息块在世界计算机中的路径。让我们再次从回到web3的主题和区块链的概念开始。当我们远离过去10年并采用更一般的理论时，“块”或“信息块”这个短语可以被认为是相同的，正如在讲座的前几部分中所探讨的那样。 “信息块”的概念与web3一致，但不一定与区块链一致。即使没有任何加密项目，我们也需要理解，当在没有参考信息块的形成的情况下形成世界计算机的理论时，目前很难设想其他模型。因此，我们将考虑信息块在整个世界计算机中的路径，不是因为它是区块链，而是因为目前除了通过以特定部分处理信息之外，没有其他方式来概念化世界计算机的存在。\n\n信息块=web3中的块，但没有区块链和没有任何加密项目的影响。当讨论世界计算机的理论时，我们目前必须考虑信息块的形。现在，让我们继续第一个观点。我尝试找到日常生活中的类比来帮助说明信息块在世界计算机中的路径。我选择的类比是公交车在路线上的移动。我们的第一个会面点是公交车站。\n\n我用粉色标记了交易作为小点。让我们想象一个典型的公交车站，人们聚集在那里，等待按时运行的公交车。如果我们不考虑大城市的喧嚣，那里的公交车总是迟到，那么世界上的每个人通常都知道从A村到B村的火车总是在早上7:15左右到达。用户想要发送到世界计算机的交易聚集在某个公交车站等待公交车到达。\n\n这就是我们的区块是如何形成的。想象一下：公共汽车到达，每个人依次上车，找到自己的座位。然后公共汽车按照它的路线行驶。在我们的情况下，信息块克服了第一个障碍。我们的交易，在某种形式上，已经进入了公共汽车并克服了最初的障碍。我将主要使用Polkadot的术语，第三部分应该更好地解释了世界计算机的概念，以太坊和Polkadot之间的比较。我的个人观点，也可能是今天大多数工程师的观点，是异构多中心世界计算机的表现更好地在Polkadot中实现。然而，我们仍将讨论从以太坊继承的术语，但在本讲座的最后部分。\n\n什么是分隔公交车站和公交车进一步移动的线？这条线代表网络的整理者 - 网络节点中收集交易的参与者。您可以将整理者视为公交车司机，而不是留在公交车站的控制器。换句话说，这个控制器检查您进入公交车时是否有车票。它不会在数据库中重新检查车票的有效性，而是查看车票的基本参数，并检查一切是否正常。实际上，整理者几乎执行所有所需的计算，验证车票号码和其他数据，但不需要保证检查是否正确完成。因，整理者是留在公交车站的控制器，主要确保乘客上车、就座并将公交车沿着路线继续前行。\n\n超出绘制边界，我们进入第一个验证区域，那里是paravalidators。这些是整个生态系统的验证者，整个网络的验证者，专门分配一定时间来检查每个交易，从而在世界计算机中执行实际计算。我们尚未完全形成的信息块用虚线标记。它仍然是一个信息块的候选，因为它尚未经过任何实际验证。整理者收集了信息块并在入口处检查了交易，但并不以任何方式参与确保进行的计算的网络安全。它的任务仅是安排所有交易并形成第一个信息块。在这个阶段，从候选到真实信息块的转变开始。\n\n我将它分成三部分，但忘记了另外一部分。让我们考虑这个候选信息块的四个部分。顶部部分，各种web3应用程序的用户称之为头部或块头，是信息的精髓，是最流行的信息片段，从区块浏览器反映到所有节点挖矿、质押等的控制台客户端。头部是信息块的关键元素，但实际上是在这一点上的最后阶段形成的。\n\n首先，我们有我们的实际状态转换或计算请求。有一系列需要进行的更改：将A转换为A'，B转换为B'，C转换为C'，对它们应用一系列算法。为此，我们现在将立即建立另一个边界，并超越它来执行这部分工作，然后才继续超越它。在信息块准备阶段，我们必须跨越世界计算机内的第二个边界，以执行需要应用于准备信息块的算法。正如我之前提到的，理论上，公交车站的控制器在这里做同样的事情，但我不会过多关注这一点。信息块准备阶段，特别是当我们同时从Polkadot和以太坊作为世界计算机的例子谈论时，它们略有不同，并显示了在这个阶段检查的无关紧要性，因为正是在第一步之后，通过第一个边界并从整理者那里收到信息块后，这个世界计算机值得关注的计算开始。\n\n\n为了执行这些计算，验证者在这个阶段只能通过转向中继链、中央数据库，并从运行时获取算法来执行。在以太坊的情况下，与之前的架构概念中相同的虚拟机可以应用，因此无需去任何地方。几乎每个节点都有完整的可应用算法副本。但在异构网络中，每个部分或每个单独的链可能有自己的算法集，验证者在实际执行所有转换之前，必须咨询从收集者那里获得的候选区块中获得的计算。它必须咨询中继链，在网络中咨询主区块链，并从那里获取必要的算法，应用它们，并执行状态转换。\n\n在执行计算过程中，同时形成了默克尔树，我们不会深入讨论它，因为从计算机科学的角度来看，默克尔树并不那么复杂。但我注意到，要理解如何在工程和项目架构中应用它们，以及它们是如何应用的，不仅仅是通过在维基百科上阅读，你需要稍微费点脑筋，想象一些例子。在这个例子中，我们不会深入讨论，但我认为对于那些已经熟悉一些基本定义，已经阅读过关于默克尔树的内容的人来说，关于另一个默克尔树是如何组装的会变得更清晰一些。当我们实际执计算并输出值时，默克尔树就形成了。这些输出值被打包成二进制树格式，然后在计算机科学语言中它们之间进行加法运算，顶部节点达到头部。让我们用一个大写字母\"H\"来表示它。这是考虑这种方案时的一个小而愉快的方面。\n\n在这个方案中，我们可以注意到区块头实际上与内部执行的计算相关联。让我们再看一遍 - 我们的区块候选者来自收集者。有一组需要执行的交易，执行计算。验证者通过另一个内部边界，再一个，经过算法，应用它们，并将所有结果记录在默克尔树的最低级别。其他节点本质上是系统性的。它们不来自任何数据；它们不来自任何地方。在第二级，节点不来自任何信息。通过在这两个叶子中的值求和获得，当我们与您一起向上移动时，我们只得到这棵树的根，这足以保护所有输出值。如果我们更改这些计算中的任何一个，我们将不会得到相同的头部。这是其中一个神奇而简单的特性，就像面向哈希的存储一样，我们如何通过只谈论一个头部来保护整个信息块。因此，头部是如此重要，并在从一个链或一个虚拟机过渡到网络中的多个链时发挥着基石作用。我们只需确保存储头部的安全性，就以确保在区块准备阶段执行的所有交易都被正确执行，它们不会被替换。\n\n还有一个字段仍然没有填写。在准备信息块的过程中，作者的字段，也就是实际执行所有更改、准备默克尔树并记录头部的验证者。由于我们考虑的是一个公交车沿着路线从车站行驶的例子，让我们称验证者为“控制器”，他直接进入公交车，经过每个座位，接近每个人，检查他们车票上写的内容是否真实，做一些标记，验证它，并相应地签名。例如，控制器编号为134，意味着每个验证者都有一些唯一标识符，他们的地址，我们也在这里以某种方式进行了独特命名。\n\n似乎在这一点上，我们本可以使我们的区块边界更加清晰和醒目，但是没有，这是过去5年中发生的有趣变化之一，即从工作证明转变。当时网络的验证者，也就是矿工，从未需要相互协调。你生成一个区块并将其发送到网络，然后继续前进。实际上，这不是一致同意的共识。这是对已发生事实的明显同意的共识。当架构变得更加复杂时，有趣的变化就会发生，我们已经从像比特币这样的简单计算器向实际虚拟计算机靠近，每个阶段，确保安全性和区块生产的参与者的连通性都在增加。因实际上没有人会冒着风险，确保这种安全性并希望通过处理您的交易来赚钱，与工作证明不同。在工作证明中，你购买了设备，是的，你投入了资金，你花费了电力，但实际上没有保护措施来防止你使用你的算力攻击网络，同样是51%攻击，其中拥有大量矿工的人可以尝试重写链。\n\n现在我们正在谈论权益证明，其中已经进行了存款，如果您做错了什么，一部分将被提取出来作为惩罚。在我目前观察到的所有架构中，所有节点绝对都开始在区块准备阶段迅速出现验证者之间的消息传递机制。在Polkadot中，情况也是如此。任何收集区块的单独平行链的验证者都知道地址，或者已经与另外15-63个与您在这个时期一起的验证者建立了联系，作为验证者，其中每个人在某个时刻都会随机成为区块生产者。但被任命为生产者并不否定这个过程的一个非常重要的组成部分。您不会停止与其他参与者互动。始终有一组验证者被分配到特定的时期，到特定的时间段，用于验证特定的平行链或世界计算机的某个部分。无论您是专门被指定为在这个部分的世界计算机中生产下一个区块的验证者控制器，您仍然与其他验证者保持联系，并与他们保持持续联系。\n\n为什么这种持续的联系是必要的？原来很简单。当我们进入内部部分时，我们不希望害怕或担心我们执行任何操作时出错。尽管可能令人惊讶，但对于任何验证者来说，在继续之前，首先向分配给验证的同事请教并要求他们再次检查计算是有益的。这种检查是非正式的，因此即使我们没有将任何日志记录到不可变的请求验证数据库以及此验证的结果，指定的控制器在与验证者池交谈后，仍然从分配给此平行链或网络段的所有验证者收集额外的响应。连同额外的确认，控制器继续进行下一阶段。但即使在这里，情况也并不那么简单。在这个阶段，还必须执行另一个过程。重要的是要注意，在这个阶段，我们的信息块仍然是候选块，并且信息的结算已经在存储中进行。在最后，或者在我们创建并封存块并将其与存档器连接在最后部分之后，即在这里，即在所有计算实际执行的这个中间部分，信息并没有保存在存储中。因此，我们的控制器除了与同事交谈外，还确保将数据存储在某个存储中，这也是相当形而上的，因为当您与其他验证者交流时，此存储会被满。这如何检查？我们需要继续进行下一阶段。\n\n总之，为了完成中间部分，让我们再次看看。我们仍然只有一个候选块在最开始。是的，在公交车站的某处粗略计算了所有交易，每个人都根据自己的车票找到了自己的座位。我们已经通过了第一个边界，这实质上是验证者和块整理者之间直接建立联系。在以太坊和Polkadot中，这些方案现在略有不同。但是在最开始左侧发生的一切并不为数据和计算提供网络安全。这只是准备。一旦我们通过并进入验证者关注的环境，与世界计算机中的信息块进行工作就开始了。在我们的情况下，随机选择的验证者，就像公交车路线上的控制器一样，实际上会检查每个座位，检查车票，检查并执行所有已经进行的计算，将所有信息汇总成一棵树。这棵树的根节点成为提议块的头部。实际上执行所有这个信息块的计算的验证者与其他参与者进行通信，这些参与者在未定义的时间段内执行相似的功能。在与他们交流并要求他们验证所有计算的过程中，我们实际上正在填充网络中的某个数据存储。这不是特定的物理存储；没有特定的IP地址，也没有通过某些VPN或登录和密码方案加载到其中的特定硬盘。在与其他验证者交流的过程中，数据仍然保留在他们的本地机器上，这些数据将进一步参与将这个候选块转化为新的信息块。实质上，将在中继链中安置的密封块被收集起来。我们已经组装好了一个块。所有围绕计算的元数据已经填充，这意味着我们可以尝试继续前进到下一个领域。\n\n在这一刻，让我们深入探讨下一个边界的过程。在最后阶段，最关键的部分是区块头。我们对计算执行不太关心；我们可以简化我们的视角，因为计算可能会根据架构的不同而有所不同，无论是以太坊还是Polkadot。关键点在于，在中间阶段，根据我在实施世界计算机概念的理论和实践中观察到的情况，大多数计算发生在中间层。最后一级仅用于执行基本检查。在多链架构中，几乎所有这些检查都与将区块头连接或合并成一个区块有关。\n\n\n在我们旅程的最后部分，世界计算机信息块中最重要的元素变成了基石 - 区块头。第二个组成部分更多地涉及元信息。如果区块头是所有计算的实际结果，那么传输的附加元信息包括参与此过程中间阶段的验证者的收据和签名。在最后阶段，我们可以将整个图像仅视为相同树的组装，而不是交易列表。在中继链的最后部分，关键的方面是从许多类似过程中组装头部，但与世界计算机的不同部分、不同平行链相关联。\n\n每个平行链，每组验证者 - 我们已经讨论了一个例子，但实际上，为平行链准备这样的区块发生了30-40。以太坊中的平行链槽数量或L2网络数量将导致具有类似架构的类似过程的数量。然而，在最后阶段，我们将在各处看到一个大致相同的图像 - 区块头将如何从其他区块的众多头部中形成。在这个过程中，我们需要引入另一个实体，并跨越边界回到第二阶段。\n\n最终者。事实上，他们也是验证者，但是中继链验证者。在Polkadot架构中，我们有一千个验证者分为两组。第一组，一个非常小的组，负责形成区块头和由各个状态区块头组成的新区块。第二组 - 平行链验证者 - 进一步分为许多子组，但这个组被称为平行链验证者。在以太坊上方的L2网络中，这个故事最终将获得更多的理解，更多的分母。现在，让我们专注于Polkadot架构。最终者，除了检查附加的元信息集并重新检查具有特定ID的验证者，随机选择生成所有区块的此区块之外，还帮助重新检查元信息，检查并将所有头部组装成一个。这有点复杂，是的，如果我们从树组装的角度来看。\n\n除此之外，在Polkadot架构和以太坊最新更改中，进行了数据可用性检查。为此，最终确认者访问平行链验证者，并尝试请求关于网络中存储的每个区块的实际信息。如果他们从至少1/3的验证者那里收到数据，使用允许信息冗余存储的技术，随后，如果有人丢失了它，一两个或三个验证者仍然可以恢复它，关键阈值为1/3。如果1/3的节点响应并表示我们有关于正在生成的区块的数据，最终确认者告诉该区块它已经是一个完全形成的信息区块，所有计算都已正确完成，我们已经获取了该区块的头部并将其与其他网络段的其他人的头部组合在一起。我们已经形成了整个网络的主头部。之后，最终确认者在最终区块上放置了许多勾号，这些勾号结合了所有已执行的计算。\n\n目前，从工程实施最多的多链异构生态系统Polkadot的角度来看，情况是这样的。这是最工程实施最多的多链异构生态系统，与以太坊相差不远。我想专注于比较，如果有人对了解以太坊与L2网络中信息块如何流动感兴趣，现在可以尝试。当以太坊的某些元素在异构性和多链方面完成时，我将回到个问题。可能需要1-2年，然后我们可以构建这样的画面。尽管如此，我们通常可以接受一个包含三个主要阶段的方案。\n\n**1. 候选信息块的形成：**\n   - 在这个阶段，信息块的初始候选者被形成。\n\n\n**2. 执行所有计算、数据存储、数据可用性、与其他节点重新检查，确保所有状态转换根据特定算法正确执行，并将这些算法存储在主要城堡中：**\n   - 这个阶段涉及实际执行计算、将数据保存到特定层，确保数据可用性，与其他节点重新检查以确认所有状态转换是否符合存储在主要城堡某处的算法。\n\n\n**3. 最终化，不会重新检查计算，但会验证元信息，以及如何存储这些元信息。然后组装最终块，即状态的状态，并将其释放为整个分段多链网络的常见信息块：**\n   - 最终阶段涉及检查元信息，验证元信息的存储方式，组装最终块（状态的状态），并将其释放为整个分段多链网络的常见信息块。\n\n\n在这一点上，我们可以说我们的信息已经保存。它已经通过了核心，核心已经正确执行了数据传输，我们已经可以使用输出值。有些人会用它们来开启一个使用智能锁购买的公寓，而其他人可能会炫耀他们刚刚用10个以太币收到的NFT。\n\n总的来说，大致就是这样。这结束了理论部分。我为大约花了2个小时，我们前面还有几个月我将录制的实践课程。它们将帮助我们理解从控制台窗口、去中心化应用程序、区块浏览器中观察到的数据，逐渐了解所有这些理论数字和字母在使用波卡作为示例时实际实现的样子。我还将开始在使用一个知名的L2构建框架进行L2级别实现时动手。感谢所有一直在观看的人。\n","fileInfo":{"path":"zh/learn/world-computer/the-path-of-a-new-block-of-information-in-the-world-computer.md","name":"the-path-of-a-new-block-of-information-in-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}