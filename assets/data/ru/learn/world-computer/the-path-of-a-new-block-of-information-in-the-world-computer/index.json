{"hash":"8d66541f6e2b7bde6cbd76ed09ec87c40b5569d7","data":{"course":{"id":"f8169d86085d8e0ab658581ccb9cd694","title":"Часть 4: Путь нового блока информации в мировом компьютере","description":"Четвертая и последняя часть нашей лекции - \"Мировой компьютер у вас дома\". После этого я начну запись скринкастов для практической части занятий.","content":"\nЧетвертая и последняя часть нашей лекции - \"Мировой компьютер у вас дома\". После этого я начну запись скринкастов для практической части занятий.\n\nТеперь мы попытаемся подвести итог почти всей теории, которую мы рассмотрели до сих пор, в терминах одного процесса. Процесс, описывающий путь информационного блока в мировом компьютере. Давайте начнем снова, вернувшись к теме web3 и концепции блокчейна. Фразу \"блок\" или \"информационный блок\" можно рассматривать как идентичные, отойдя от последних 10 лет и приняв более общую теорию, как это было исследовано в предыдущих частях лекций. Концепция \"блока информации\" соответствует web3, но не обязательно блокчейну. Даже без каких-либо криптопроектов, нам нужно понимать, что при формировании теории мирового компьютера без ссылки на формирование информационных блоков в настоящее время сложно представить другие модели. Поэтому мы рассмотрим путь информационного блока по всему мировому компьютеру не потому, что это блокчейн, а потому что на данный момент нет других способов концептуализировать существование мирового компьютера, кроме как обработка информации в определенных порциях.\n\nБлок информации = блок в web3, но без блокчейна и без влияния каких-либо криптопроектов. Мы должны в настоящее время учитывать формирование информационных блоков, когда обсуждаем теорию мирового компьютера. Теперь перейдем к первой точке. Я пытался найти близкие аналогии из повседневной жизни, чтобы помочь проиллюстрировать путь информационного блока в мировом компьютере. Аналогией, которую я выбрал, является движение автобуса по маршруту. Наша первая встречная точка - автобусная остановка.\n\nЯ отметил транзакции розовым цветом как маленькие точки. Давайте представим типичную автобусную остановку, где люди собираются, ожидая автобус, который ходит по расписанию. Если не учитывать суету больших городов, где автобусы всегда опаздывают, все в мире обычно знают, что поезд из деревни А в деревню В всегда прибывает около 7:15 утра. Транзакции, которые пользователи хотят отправить в мировой компьютер, собираются на определенной автобусной остановке и ждут прибытия автобуса.\n\nЭто то, как формируется наш блок. Представьте: автобус приезжает, и каждый человек начинает по очереди садиться на свои места. Затем автобус следует своему маршруту. В нашем случае блок информации преодолевает первую границу. Наши транзакции, в какой-то форме, утвердились в автобусе и преодолели первое препятствие. Я буду использовать терминологию в основном из Polkadot, и третья часть должна была лучше объяснить концепцию мирового компьютера в сравнении между Ethereum и Polkadot. Мое личное мнение, и, вероятно, большинство инженеров сегодня согласились бы, что представление гетерогенного мультицентрического мирового компьютера лучше реализовано в Polkadot. Однако мы все равно пройдем через термины, унаследованные от Ethereum, но к концу этой части лекции.\n\nКакая линия отделяет автобусную остановку от дальнейшего движения автобуса? Эта линия представляет собой коллаторов сети - участников узлов сети, собирающих транзакции. Вы можете думать о коллаторе не как о водителе автобуса, а как о контроллере, который остается на автобусной остановке. Другими словами, этот контроллер проверяет, есть ли у вас билет при входе в автобус. Он не перепроверяет в базе данных, насколько действителен билет, а смотрит на основные параметры билета и проверяет, все ли в порядке. На самом деле коллаторы выполняют практически все необходимые вычисления, проверяя номер билета и другие данные, но им не требуется гарантировать, что проверка выполнена правильно. Поэтому коллаторы - это контроллеры, которые остаются на автобусной остановке, в первую очередь обеспечивая посадку пассажиров, занятие мест и отправку автобуса дальше по маршруту.\n\nЗа нарисованной границей мы входим в первую зону валидации, где находятся паравалидаторы. Это валидаторы всей экосистемы, всей сети, специально назначенные на определенное время для проверки каждой транзакции и тем самым выполнения фактических вычислений в мировом компьютере. Наш еще не полностью сформированный блок информации отмечен пунктирной линией. Это все еще кандидат на блок информации, поскольку он не прошел никакой фактической проверки. Коллатор, который собрал блок информации и проверил транзакции на входе, никоим образом не участвует в обеспечении кибербезопасности проводимых вычислений. Его задача - только посадить все транзакции и сформировать первый блок. На этом этапе начинается преобразование из кандидата в реальный блок информации.\n\nЯ разделил это на три части, но забыл еще одну. Давайте рассмотрим четыре части этого кандидата на блок. Верхняя часть, известная пользователям различных веб-приложений web3 как заголовок или блочный заголовок, является квинтэссенцией, самым популярным куском информации, циркулирующим и отраженным от блок-эксплорера к консольным клиентам всех узлов, майнящих, стейкингующих и так далее. Заголовок - ключевой элемент блока, но он практически формируется на последнем этапе на данном этапе.\n\nВо-первых, у нас есть наши фактические запросы на переходы состояний или вычисления. Есть список изменений, которые необходимо внести: преобразовать A в A', B в B', C в C', применяя к ним набор алгоритмов. Для этого мы сейчас построим еще одну границу немедленно и перейдем за нее, чтобы выполнить эту часть работы, а затем только продолжим за нее. Уже на этапе подготовки блока нам придется пересечь вторую границу внутри мирового компьютера, чтобы перейти к алгоритмам, которые необходимо применить для подготовки блока. Как я уже упоминал ранее, теоретически контроллер на автобусной остановке здесь делает то же самое, но я бы не уделял этому много внимания. Этап подготовки блока, особенно когда мы говорим о примерах одновременно из Polkadot и Ethereum как мирового компьютера, они немного отличаются и показывают нам незначительность проверок на этом этапе, потому что именно на втором шаге, после прохождения первой границы и получения блока информации от коллаторов, начинаются достойные внимания вычисления этого мирового компьютера.\n\n\nДля выполнения этих вычислений валидатор на данном этапе может сделать это только обратившись к ретрансляционной цепи, центральной базе данных и взяв оттуда алгоритмы из времени выполнения. В случае Ethereum это были те же виртуальные машины в предыдущей архитектурной концепции, которые могли быть применены, поэтому никуда ходить не приходилось. Почти каждый узел имел полную копию алгоритмов, которые могли быть применены. Но в случае гетерогенной сети, где каждый сегмент или каждая отдельная цепь могут иметь свой набор алгоритмов, валидатору, прежде чем фактически выполнить все переходы, вычисления, полученные в виде кандидата в блоке от коллатора, необходимо проконсультироваться. Он должен проконсультироваться с ретрансляционной цепью, проконсультироваться с основным блокчейном в сети и взять оттуда необходимые алгоритмы, применить их и выполнить переходы состояний.\n\nВо время выполнения вычислений одновременно формируется дерево Меркля, и мы не будем останавливаться на этом, потому что деревья Меркля не настолько сложны с точки зрения компьютерных наук. Тем не менее, я замечаю, что для понимания того, как их применять в инженерии и в архитектуре проекта, как они применяются, не просто читая на Википедии, нужно немного постараться, представить примеры. В этом примере мы не будем слишком углубляться, но я думаю, что для тех, кто уже знаком с некоторыми основными определениями, прочитал о деревьях Меркля, станет немного яснее, как и в какие моменты собирается другое дерево Меркля. Дерево Меркля формируется, когда мы фактически выполняем вычисления и появляются выходные значения. Эти выходные значения упаковываются в двоичный формат дерева, затем выполняется сложение между ними на языке компьютерных наук, и верхний узел достигает заголовка. Давайте обозначим его большой буквой \"H.\" Это маленький и приятный аспект рассмотрения таких схем.\n\nВ этой схеме мы можем отметить, как заголовок блока фактически связан с выполненными внутри вычислениями. Давайте посмотрим еще раз - наш кандидат в блок пришел от коллатора. Есть набор транзакций, которые нужно выполнить, выполнить вычисления. Валидатор прошел через еще одну внутреннюю границу, еще одну, за алгоритмами, применил их и записал все результаты на самом низком уровне дерева Меркля. Другие узлы в основном системные. Они не происходят от каких-либо данных, они не приходят откуда-либо. На втором уровне узел не происходит от какой-либо информации. Он получается путем суммирования значений в этих двух листьях, и когда мы поднимаемся вместе с вами, мы получаем только корень этого дерева, что достаточно для защиты всех выходных значений. Мы не получим тот же заголовок, если изменим хотя бы одно из этих вычислений. И это одна из волшебных и простых особенностей, как хэш-ориентированное хранение, как мы можем защитить целый блок информации, говоря только о одном заголовке. Поэтому заголовки настолько важны и играют ключевую роль даже в архитектурах, когда мы переходим от одной цепи или одной виртуальной машины к множеству объединенных в сети. Для нас достаточно обеспечить безопасность хранения заголовков, чтобы быть уверенными, что все транзакции, которые были выполнены на этапе подготовки блока, были выполнены правильно и их нельзя заменить.\n\nИ одно поле все еще остается незаполненным. В процессе подготовки блока информации это поле автора, то есть валидатора, который фактически выполнил все изменения, подготовил дерево Меркля и записал заголовок. Поскольку мы рассматриваем пример с автобусом, движущимся по маршруту от остановки, давайте назовем валидатора \"контролером\", который заходит прямо в автобус, проходит мимо каждого места, подходит к каждому человеку, проверяет на деле то, что написано на их билетах, ставит отметку, валидирует это и, соответственно, ставит свою подпись. Контролер, например, номер 134, что означает, естественно, что у каждого валидатора есть уникальный идентификатор, их адрес, и мы также как-то уникально переименовали это здесь.\n\nИ кажется, что на этом этапе мы могли бы затенить и сделать наши границы блока жирнее, но нет, и это одно из интересных изменений, которые произошли за последние 5 лет в терминах децентрализованных экосистем, а именно сдвиг от доказательства работы. Когда валидаторы сети, тогда майнеры, никогда не должны были координировать что-либо друг с другом. Вы создавали блок и отправляли его в сеть и двигались дальше. Фактически это не было согласием о согласии. Это было согласием на очевидное согласие с тем, что произошло. Что интересно при изменениях, когда архитектура становится более сложной, и мы приближаемся от простого калькулятора, как Bitcoin с реестром, к фактическому виртуальному компьютеру, это то, что на каждом этапе связь участников, обеспечивающих безопасность и производство блоков, увеличивается. Потому что, фактически, никто, кто рискует своей долей, тот, кто обеспечивает эту безопасность и хочет заработать, обрабатывая ваши транзакции, не имеет чего терять, в отличие от доказательства работы. В доказательстве работы вы покупали оборудование, да, вы вкладывали в него деньги, тратили электроэнергию, но на самом деле нет защиты от того, что вы можете атаковать сеть своей мощностью, та же атака 51%, где кто-то с большим количеством майнеров может попытаться переписать цепочку.\n\nСейчас мы говорим о доказательстве доли, где депозит уже сделан, и если вы сделаете что-то неправильно, часть будет изъята из него в качестве штрафа. Все узлы, абсолютно, во всех архитектурах, которые я в настоящее время наблюдаю, механизмы обмена сообщениями между валидаторами начали появляться быстро на этапе подготовки блока. В Polkadot это не исключение. Любой валидатор отдельной парачейны, собирающий блок, знает адреса или уже установил контакт с другими 15-63 валидаторами, которые находятся с вами на этой эпохе, на какой-то временный период, как валидаторы, и каждый из них случайным образом становится производителем блока в определенный момент. Но назначение на производство не отменяет очень важного компонента этого процесса. Вы не прекращаете взаимодействие с другими участниками. Всегда есть пул валидаторов, назначенных на определенную эпоху, на определенный временной слот, для проверки определенной парачейны или сегмента мирового компьютера. Независимо от того, являетесь ли вы валидатором-контроллером, специально назначенным для производства следующего блока в мировом компьютере этого сегмента, вы все равно остаетесь на связи с другими валидаторами и постоянно находитесь в контакте с ними.\n\nЗачем нужен этот постоянный контакт? Оказывается, все довольно просто. Мы не хотим, чтобы, переходя во внутреннюю часть, бояться или беспокоиться о том, что мы выполнили какие-либо операции неправильно. Как ни удивительно, это полезно для любого валидатора, прежде чем перейти к следующему этапу, обратиться к своим коллегам, ответственным за валидацию, и попросить их дважды проверить вычисления. Эта проверка неофициальная, поэтому даже если мы не используем какие-либо журналы в неизменяемой базе данных запросов на проверку и результатов этой проверки, назначенный контроллер, после разговора с пулом валидаторов, все равно собирает дополнительные ответы от всех валидаторов, назначенных на эту парачейну или сегмент сети. Вместе с дополнительными подтверждениями контроллер переходит к следующему этапу. Но даже здесь все не так просто. На этом этапе должен быть выполнен еще один процесс. Важно отметить, что на этом этапе наш блок информации все еще является кандидатским блоком, и урегулирование информации уже происходит в хранилище. Ни в самом конце, ни после того, как мы создали и запечатали блок и присоединили его с архиватором в конечной части, а именно здесь, в этой средней части, где все вычисления фактически выполняются, информация не сохраняется в хранилище. Поэтому наш контроллер, помимо общения со своими коллегами, также обеспечивает хранение данных в каком-то хранилище, что также довольно метафизично, потому что в момент общения с другими валидаторами это хранилище заполняется. Как это проверяется? Нам нужно перейти к следующему этапу.\n\nВ общем, чтобы завершить среднюю часть, давайте посмотрим еще раз. У нас все еще есть только кандидатский блок в самом начале. Да, все транзакции грубо рассчитаны где-то на автобусной остановке, каждый занял свое место в соответствии с билетами. Мы прошли первую границу, которая по сути представляет собой прямой установленный контакт между валидаторами и сборщиками блоков. В Ethereum и Polkadot эти схемы немного отличаются сейчас. Но все, что происходит слева в самом начале, не обеспечивает кибербезопасность для данных и вычислений. Это просто подготовка. Как только мы прошли и вошли в среду внимания валидаторов, начинается работа с блоком информации в мировом компьютере. Случайно выбранный валидатор, в нашем случае, с маршрутом автобуса - контроллер, фактически проходит через каждое место, проверяет билет, проверяет и выполняет все вычисления, которые были сделаны, собирает всю информацию в дерево. Полученный корневой узел этого дерева становится заголовком предложенного блока. Валидатор, который фактически выполняет все вычисления с этим блоком информации, общается с другими участниками, которые выполняют аналогичную функцию для того же маршрута в неопределенный временной интервал. И, общаясь с ними и просив их проверить все вычисления, мы фактически заполняем определенное хранилище данных в сети. Это не конкретное физическое хранилище; нет конкретного IP-адреса, нет конкретного жесткого диска, на который все загружают через какую-то VPN или схему входа и пароля, конечно. В процессе общения с другими валидаторами данные остаются на их локальных машинах, и эти данные далее будут участвовать в преобразовании этого кандидата в новый блок информации. По сути, собирается запечатанный блок, который будет урегулирован в ретрансляционной цепи. Мы собрали блок. Вся метаданные вокруг вычислений уже заполнены, что означает, что мы можем попытаться перейти к следующей границе.\n\nНа данный момент давайте погрузимся в прохождение следующей границы. Самым важным аспектом на последнем этапе становится заголовок блока. Мы меньше беспокоимся о выполнении вычислений; мы можем упростить наш взгляд здесь, так как вычисления могут различаться в зависимости от архитектуры, будь то Ethereum или Polkadot. Ключевой момент заключается в том, что на промежуточном этапе, из того, что я наблюдаю в теории и практике реализации концепции мирового компьютера, большинство вычислений происходят на промежуточном уровне. Последний уровень остается только для выполнения основных проверок. Почти все эти проверки в мультицепочной архитектуре связаны с конкатенацией или объединением заголовков блоков.\n\n\nНа последнем этапе нашего путешествия самым важным элементом в информационном блоке мирового компьютера становится краеугольный камень - заголовок. Второй компонент больше о мета-информации. Если заголовок является фактическим результатом всех вычислений, то дополнительная мета-информация, передаваемая, состоит из квитанций и подписей валидаторов, участвовавших на промежуточном этапе этого процесса. На последнем этапе мы можем визуализировать всю картину исключительно как сборку одного и того же дерева, а не как список транзакций. В последней части ретрансляционной цепи ключевым аспектом является сборка заголовков из множества аналогичных процессов, но связанных с различными сегментами мирового компьютера, различными парачейнами.\n\nКаждый парачейн, каждый набор валидаторов - мы обсудили один пример, но на самом деле подобные подготовки блоков для парачейнов происходят 30-40 раз. Количество слотов парачейнов или количество L2-сетей в Ethereum приведет к подобному количеству процессов с аналогичной архитектурой. Однако на последнем этапе мы увидим примерно одинаковую картину везде - как будет формироваться заголовок блока из множества заголовков из других блоков. В этом процессе нам нужно ввести еще одну сущность и перескочить через границу на второй этап.\n\nФинализаторы. Фактически, они также являются валидаторами, но валидаторами ретрансляционной цепи. В архитектуре Polkadot у нас тысяча валидаторов, разделенных на две группы. Первая, очень маленькая группа, отвечает только за формирование заголовка блока и нового блока, состоящего из заголовков блоков Состояния Состояний. Вторая группа - валидаторы парачейнов - дополнительно разделена на множество подгрупп, но эта группа называется валидаторами парачейнов. В L2-сетях над Ethereum эта история в конечном итоге приобретет больше понимания, больше знаменателей. Пока что давайте сосредоточимся на архитектуре Polkadot. Финализаторы, помимо проверки дополнительного набора мета-информации и повторной проверки валидатора с определенным идентификатором, случайно выбранным для генерации этого блока из всех блоков, также помогают повторно проверить мета-информацию, проверить и собрать все заголовки в один. Это немного сложно, да, если мы посмотрим на это с точки зрения сборки дерева.\n\nКроме того, в архитектуре Polkadot и в Ethereum с последними изменениями происходит проверка доступности данных. Для этого финализаторы посещают валидаторов парачейн и пытаются запросить фактическую информацию о каждом блоке, хранящемся в сети. Если они получают данные от по крайней мере 1/3 валидаторов, используя технологию, позволяющую избыточное хранение информации, и впоследствии, если кто-то ее потеряет, один или два или три валидатора все равно могут восстановить ее, существует критический порог на уровне 1/3. Если 1/3 узлов отвечают и говорят, что у нас есть данные о производимом блоке, финализаторы сообщают блоку, что это уже полностью сформированный информационный блок, что все вычисления были выполнены правильно, что мы уже взяли заголовок этого блока и объединили его с заголовками других сегментов сети. Мы уже сформировали основной заголовок всей сети. После этого финализаторы ставят много галочек на финальном блоке, который объединяет все выполненные вычисления.\n\nВ настоящее время это ситуация с точки зрения наиболее инженерно реализованной мультицепочечной гетерогенной экосистемы, которая является Polkadot. Это наиболее инженерно реализованная мультицепочечная гетерогенная экосистема, не слишком далекая от Ethereum. Я бы хотел сосредоточиться на сравнении, и если кто-то заинтересован в понимании того, как информационные блоки передаются в Ethereum с сетями L2, вы можете попробовать сделать это сейчас. Я вернусь к этому вопросу, когда некоторые элементы Ethereum, с точки зрения гетерогенности и мультицепочечных аспектов, будут завершены. Это может занять 1-2 года, и тогда мы сможем построить такую картину. Тем не менее, мы можем в общем принять схему с тремя основными этапами:\n\n**1. Формирование кандидата для информационного блока:**\n   - На этом этапе формируется начальный кандидат для информационного блока.\n\n\n**2. Выполнение всех вычислений, хранение данных, доступность данных, повторная проверка с другими узлами, обеспечение того, что все переходы состояний выполняются правильно в соответствии с конкретными алгоритмами и хранение этих алгоритмов в основном цитаделе:**\n   - Этот этап включает в себя фактическое выполнение вычислений, сохранение данных на определенных уровнях, обеспечение доступности данных, повторную проверку с другими узлами для подтверждения того, что все переходы состояний соответствуют алгоритмам, хранящимся где-то в основном цитаделе.\n\n\n**3. Финализация, которая не будет повторно проверять вычисления, но будет проверять мета-информацию, как эта мета-информация хранится. Затем она соберет окончательный блок, который является состоянием состояний, и выпустит его как общий информационный блок для всей сегментированной мультицепочной сети:**\n   - Финальный этап включает проверку мета-информации, проверку того, как эта мета-информация хранится, сбор окончательного блока (состояние состояний) и выпуск его как общего информационного блока для всей сегментированной мультицепочной сети.\n\n\nНа этом этапе мы можем сказать, что наша информация сохранена. Она прошла через сердце, сердце правильно передало свои данные, и мы уже можем использовать выходные значения. Некоторые будут использовать их, чтобы открыть квартиру, купленную смарт-контрактом с смарт-замком, в то время как другие могут похвастаться своим NFT, только что полученным за 10 эфиров.\n\nВ общем, примерно так это работает. Этим завершается теоретическая часть. Я думаю, что это заняло около 2 часов, и перед нами практические занятия, которые я буду записывать в течение следующих нескольких месяцев. Они помогут нам понять наблюдаемые данные из окна консоли, децентрализованные приложения, блок-эксплореры, где мы постепенно поймем, как все эти теоретические цифры и буквы на самом деле выглядят в реализации, используя Polkadot в качестве примера. Я также начну практическую работу с реализациями на уровне L2 с использованием одного из известных фреймворков для построения L2. Спасибо всем, кто смотрел.\n","fileInfo":{"path":"ru/learn/world-computer/the-path-of-a-new-block-of-information-in-the-world-computer.md","name":"the-path-of-a-new-block-of-information-in-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}