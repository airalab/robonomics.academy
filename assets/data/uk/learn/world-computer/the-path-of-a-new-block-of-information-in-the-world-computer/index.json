{"hash":"875b98d13319980e3d246b684c60c311a25b65d1","data":{"course":{"id":"dd89c22f5d3e7b031b1f467ef7d94e38","title":"Частина 4: Шлях нового блоку інформації у світовому комп'ютері","description":"Четверта і остання частина нашої лекції - \"Світовий комп'ютер у вашому домі\". Після цього я почну записувати скрінкасти для практичної частини занять.","content":"\nЧетверта і остання частина нашої лекції - \"Світовий комп'ютер у вашому домі\". Після цього я почну записувати скрінкасти для практичної частини занять.\n\nТепер ми спробуємо узагальнити майже всю теорію, яку ми вже розглянули, у термінах одного процесу. Процес, який описує шлях блоку інформації у світовому комп'ютері. Давайте почнемо знову, повернувшись до теми web3 та концепції блокчейну. Фразу \"блок\" або \"блок інформації\" можна вважати ідентичними, коли віддалимося від останніх 10 років і взяли більш загальну теорію, як досліджено в попередніх частинах лекцій. Концепція \"блоку інформації\" відповідає web3, але не обов'язково блокчейну. Навіть без будь-яких криптопроектів, нам потрібно розуміти, що, формуючи теорію світового комп'ютера без посилання на формування блоків інформації, наразі складно уявити інші моделі. Тому ми розглянемо шлях блоку інформації по всьому світовому комп'ютеру, не тому що це блокчейн, а тому що наразі немає інших способів уявити існування світового комп'ютера, крім обробки інформації в конкретних порціях.\n\nБлок інформації = блок у web3, але без блокчейну та без впливу будь-якого криптопроекту. Наразі ми повинні розглядати формування блоків інформації, коли обговорюємо теорію світового комп'ютера. Тепер перейдемо до першої точки. Я намагався знайти близькі аналогії з повсякденного життя, щоб допомогти проілюструвати шлях блоку інформації у світовому комп'ютері. Аналогія, яку я обрав, - це рух автобуса по маршруту. Наша перша зустрічна точка - автобусна зупинка.\n\nЯ позначив транзакції рожевими як маленькі крапки. Уявімо типову автобусну зупинку, де люди збираються, чекаючи на автобус, який працює за розкладом. Якщо не враховувати гамір великих міст, де автобуси завжди запізнюються, всі в світі загалом знають, що поїзд з села А до села Б завжди прибуває близько 7:15 ранку. Транзакції, які користувачі хочуть відправити у світовий комп'ютер, збираються на певній автобусній зупинці і чекають, коли прибуде автобус.\n\nОсь як формується наш блок. Уявіть: автобус прибуває, і кожна людина починає сідати по одній, займаючи свої місця. Потім автобус йде своєю маршрутом. У нашому випадку блок інформації подолав перший фронт. Наші транзакції, у певній формі, вже встигли увійти в автобус і подолати початковий бар'єр. Я буду використовувати термінологію в основному з Polkadot, і третя частина повинна краще пояснити концепцію світового комп'ютера в порівнянні між Ethereum та Polkadot. Моя особиста думка, і, ймовірно, більшість інженерів сьогодні погодилися б, полягає в тому, що представлення гетерогенного багатоцентрового світового комп'ютера краще реалізовано в Polkadot. Однак ми все ще пройдемо терміни, успадковані від Ethereum, ал в кінці цієї частини лекції.\n\nЯка лінія відокремлює автобусну зупинку від подальшого руху автобуса? Ця лінія представляє колаторів мережі - учасників вузлів мережі, які збирають транзакції. Ви можете уявляти колатора не як водія автобуса, а як контролера, який залишається на автобусній зупинці. Іншими словами, цей контролер перевіряє, чи є у вас квиток при вході в автобус. Він не перевіряє в базі даних, наскільки дійсний квиток, але дивиться на основні параметри квитк і перевіряє, чи все виглядає належним чином. На практиці колатори виконують майже всі необхідні обчислення, перевіряючи номер квитка та інші дані, але їм не потрібно гарантувати, що перевірка виконана правильно. Тому колатори - це контролери, які залишаються на автобусній зупинці, в основному забезпечуючи посадку пасажирів, розміщення та відправлення автобуса далі по маршруту.\n\nПоза намальованою межею ми входимо в першу зону перевірки, де розташовані паравалідатори. Це валідатори всього екосистеми, всієї мережі, спеціально призначені на певний час для перевірки кожної транзакції та виконання фактичних обчислень у світовому комп'ютері. Наш ще не повністю сформований блок інформації позначений пунктирною лінією. Це все ще кандидат на блок інформації, оскільки він не пройшов жодної фактичної перевірки. Колатор, який зібрав блок інформації та перевірив транзакції на вході, не бере участь у забезпеченні кібербезпеки обчислень, які проводяться. Його завдання - лише розмістити всі транзакції та сформувати перший блок. На цьому етапі починається перетворення з кандидата на реальний блок інформації.\n\nЯ розділив це на три частини, але забув ще одну. Давайте розглянемо чотири частини цього кандидатського блоку. Верхня частина, відома користувачам різних додатків web3 як заголовок або блочний заголовок, є сутністю, найпопулярнішим шматком інформації, що циркулює та відображається з блок-експлорера на консольні клієнти всіх вузлів, які майнять, стейкують та інше. Заголовок є ключовим елементом блоку, але він практично формується на останньому етапі на цей момент.\n\nПо-перше, у нас є наші фактичні запити на переходи стану або обчислення. Є список змін, які потрібно внести: перетворити A на A', B на B', C на C', застосовуючи до них набір алгоритмів. Для цього ми зараз побудуємо ще одну межу негайно і вийдемо за її межі, щоб виконати цю частину роботи, а потім лише продовжимо за її межі. Вже на етапі підготовки блоку нам доведеться перетнути другу межу всередині світового комп'ютера, щоб перейти до алгоритмів, які потрібно застосувати для підготовки блоку. Як я вже зазначив раніше, теоретично контролер на автобусній зупинці тут робить те ж саме, але я б не звертав на це багато уваги. Етап підготовки блоку, особливо коли ми говоримо про приклади одночасно з Polkadot та Ethereum як світового комп'ютера, вони трохи відрізняються і показують нам незначність перевірок на цьому етапі, оскільки саме на другому кроці, після проходження першої межі та отримання блоку інформації від колаторів, починаються варте уваги обчислення цього світового комп'ютера.\n\n\nДля виконання цих обчислень перевірник на цьому етапі може робити це лише звертаючись до релеєвого ланцюжка, центральної бази даних, і брати звідти алгоритми з рантайму. У випадку Ethereum, це були ті самі віртуальні машини в попередньому архітектурному концепції, які можна було застосовувати, тому нікуди йти не потрібно було. Майже кожен вузол мав повну копію алгоритмів, які можна було застосувати. Але в термінах гетерогенної мережі, де кожний сегмент або кожен окремий ланцюжок може мати свій власний набір алгоритмів, перевірник, перед тим як фактично виконати всі переходи, обчислення, отримані у вигляді кандидата на блок від коллатора, повинен проконсультуватися. Він повинен проконсультуатися з релеєвим ланцюжком, проконсультуватися з основним блокчейном в мережі і взяти звідти необхідні алгоритми, застосувати їх і виконати переходи стану.\n\nПід час виконання обчислень одночасно формується дерево Меркла, і ми не будемо зупинятися на цьому, оскільки дерева Меркла не настільки складні з точки зору комп'ютерних наук. Проте я зауважую, що для розуміння того, як їх застосовувати в інженерії та в архітектурі проекту, як вони застосовуються, не лише читаючи на Вікіпедії, потрібно трохи поламати голову, уявити приклади. У цьому прикладі ми не будемо занадто глибоко вдаватися в це, але я думаю, що для тих, хто вже знайомий з деякими базовими визначеннями, прочитав про дерева Меркла, стане трохи зрозуміліше, як і в які моменти формуться інше дерево Меркла. Дерево Меркла формується, коли ми фактично виконуємо обчислення і з'являються вихідні значення. Ці вихідні значення упаковуються у бінарний формат дерева, потім виконується додавання між ними мовою комп'ютерних наук, і верхній вузол доходить до заголовка. Давайте позначимо його великою літерою \"H.\" Це невеликий і приємний аспект розглядання таких схем.\n\nУ цій схемі ми можемо зауважити, як заголовок блоку фактично пов'язаний з обчисленнями, виконаними всередині. Давайте ще раз подивимося - наш кандидат на блок прийшов від коллатора. Є набір транзакцій, які потрібно виконати, виконати обчислення. Перевірник пройшов через ще одну внутрішню межу, ще одну, за алгоритмами, застосував їх і записав всі результати на найнижчому рівні дерева Меркла. Інші вузли в основному системні. Вони не походять з жодних даних; вони не приходять звідки-небудь. На другому рівні вузол не походить з жодної інформації. Він отримується шляхом сумування значень в цих двох листках, і коли ми йдемо вгору з вами, ми отримуємо лише корінь цього дерева, що достатньо для захисту всіх вихідних значень. Ми не отримаємо того самого заголовка, якщо змінимо будь-які з цих обчислень. І це одна з чарівних і простих функцій, як напрямлене зберігання хешів, як ми можемо захистити цілу блок-інформацію, говорячи лише про один заголовок. Тому заголовки настільки важливі і відіграють ключову роль навіть в архітектурах, коли ми переходимо з одного ланцюжка або однієї віртуальної машини до багатьох, об'єднаних в мережу. Для нас достатньо забезпечити безпеку зберігання заголовків, щоб бути впевненими, що всі транзакції, які були виконані на етапі підготовки блоку, були виконані правильно, і їх не можна замінити.\n\nІ одне поле все ще залишається незаповненим. У процесі підготовки блоку інформації це поле автора, тобто валідатора, який фактично виконав всі зміни, підготував дерево Меркла та записав заголовок. Оскільки ми розглядаємо приклад з автобусом, який рухається вздовж маршруту від зупинки, давайте назвемо валідатора \"контролером\", який заходить прямо всередину автобуса, проходить кожне місце, підходить до кожної людини, перевіряє реальність того, що написано на їх квитках, робить певну позначку, підтверджує це та, відповідно, ставить свій підпис. Контролер, наприклад, номер 134, що означає, звичайно, що кожен валідатор має унікальний ідентифікатор, свою адресу, і ми також якось унікально переменували його.\n\nІ здається, що на цьому етапі ми могли б затінити та зробити наші межі блоку більш виразними, але ні, і це одна з цікавих змін, які відбулися за останні 5 років у термінах децентралізованих екосистем, а саме зміна з доказу роботи. Коли валідатори мережі, тоді шахтарі, ніколи не мали потреби узгоджувати щось один з одним. Ви створювали блок та відправляли його в мережу та йшли далі. Фактично це не було консенсусом узгодженої згоди. Це був консенсус очевидної згоди з тим, що відбулося. Що цікаво, зміни, коли архітектура стає складнішою, і ми наближаємося від простого калькулятора, подібного до Bitcoin з рахунком, до фактичного віртуального комп'ютера, полягає в тому, що на кожному етапі збільшується зв'язаність учасників, які забезпеують безпеку та виробництво блоків. Тому що, фактично, ніхто, хто ризикує своїм ставкою, той, хто забезпечує цю безпеку та хоче заробити, обробляючи ваші транзакції, не має чого втрачати, на відміну від доказу роботи. У доказі роботи ви купуєте обладнання, так, ви вкладаєте гроші в нього, витрачаєте електроенергію, але фактично немає захисту від того, що ви можете атакувати мережу своєю потужністю, та сама атака на 51%, де хтось з великою кількістю шахтарів може спробувати переписати ланцюжок.\n\nЗараз ми говоримо про доказ власності, де вже зроблено депозит, і якщо ви щось зробите неправильно, з нього буде знято частину як покарання. Усі вузли, абсолютно, в усіх архітектурах, які я зараз спостерігаю, механізми обміну повідомленнями між валідаторами почали швидко з'являтися на етапі підготовки блоку. У Polkadot це не відрізняється. Будь-який валідатор окремого парачейну, який збирає блок, знає адреси або вже встановив контакт з іншими 15-63 валідаторами, які з вами на цій епосі, на певний тимчасовий період, як валідатори, і кожен з них випадковим чином стає виробником блоку в певний момент. Але призначення виробником не відміняє дуже важливої складової цього процесу. Ви не припиняєте взаємодію з іншими учасниками. Завжди є пул валідаторів, призначених для певної епохи, для певного часового інтервалу, для перевірки певного парачейну або сегмента світового комп'ютера. Незалежно від того, чи ви є валідатор-контролером, спеціально призначеним для виробництва наступного блоку у світовому комп'ютері цього сегмента, ви все ще знаходитесь на зв'язку з іншими валідаторами, і ви постійно з ними контактуєте.\n\nЧому цей постійний контакт необхідний? Виявляється, це досить просто. Ми не хочемо, коли ми переходимо до внутрішньої частини, боятися або перейматися тим, що ми виконали будь-які операції неправильно. Незважаючи на те, наскільки це може здатися дивним, це корисно для будь-якого валідатора, перед тим як переходити далі, спочатку звернутися до своїх колег, які призначені для валідації, і попросити їх перевірити розрахунки. Ця перевірка є неформальною, тому навіть якщо ми не використовуємо жодного журналювання в незмінній базі даних запитів на перевірку та результатів цієї перевірки, призначений контролер, після розмови з пулом валідаторів, все ще збирає додаткові відповіді від усіх валідаторів, які призначені для цієї парачейн або сегменту мережі. Разом з додатковими підтвердженнями контролер переходить до наступного етапу. Але навіть тут все не так просто. На цьому етапі потрібно виконати ще один процес. Важливо зауважити, що на цьому етапі наш блок інформації все ще є кандидатським блоком, і вже відбувається вирішення інформації в сховищі. Ні в самому кінці, ні після того, як ми створили і запечатали блок і прикріпили його з архіватором в кінцевій частині, а саме тут, в цій середній частині, де всі розрахунки фактично виконуються, інформація не зберігається в сховищі. Тому наш контролер, крім розмови з колегами, також забезпечує збереження даних в деякому сховищі, що також досить метафізично, оскільки в момент спілкування з іншими валідаторами це сховище заповнюється. Як це перевіряється? Нам потрібно перейти до наступного етапу.\n\nУ підсумку, щоб завершити середню частину, давайте ще раз подивимося. У нас все ще є лише кандидатський блок в самому початку. Так, всі транзакції приблизно розраховані десь на автобусній зупинці, кожен зайняв свої місця відповідно до своїх квитків. Ми пройшли першу межу, яка суттєво встановила прямий контакт між валідаторами та блок-коллекторами. У Ethereum та Polkadot це зараз трохи різні схеми. Але все, що відбувається зліва в самому початку, не забезпечує кібербезпеку для даних та розрахунків. Це лише підготовка. Як тільки ми пройшли та увійшли в середовище уваги валідаторів, починається робота з блоком інформації у світовому комп'ютері. Випадково обраний валідатор, у нашому випадку, з маршруто автобуса - контролер, фактично проходить кожне з місць, перевіряє квиток, перевіряє та виконує всі розрахунки, збирає всю інформацію в дерево. Отриманий кореневий вузол цього дерева стає заголовком запропонованого блоку. Валідатор, який фактично виконує всі розрахунки з цим блоком інформації, спілкується з іншими учасниками, які виконують схожу функцію для того ж маршруту в невизначеному часовому інтервалі. І під час спілкування з ними та прохання їх перевірити всі розрахунки, ми фактично наповнюємо певне сховище даних в мережі. Це не конкретне фізичне сховище; тут немає конкретної IP-адреси, жорсткого диска, на який вони всі завантажують через якусь VPN або схему входу та пароля, звичайно, ні. Під час спілкування з іншими валідаторами дан залишаються на їхніх локальних машинах, і ці дані подальше братимуть участь у перетворенні цього кандидата в новий блок інформації. По суті, зібраний блок, який буде врегульований у реле-ланцюгу. Ми зібрали блок. Усі метадані навколо розрахунків вже заповнені, що означає, що ми можемо спробувати перейти до наступної фронтирної зони.\n\nНа цей момент давайте поглибимося в проходження наступної межі. Найважливішим аспектом на останньому етапі стає заголовок блоку. Ми менше звертаємо увагу на виконання обчислень; ми можемо спростити нашу перспективу тут, оскільки обчислення можуть відрізнятися в залежності від архітектури, чи то Ethereum, чи Polkadot. Ключовий момент полягає в тому, що на проміжному етапі, з того, що я спостерігаю в теорії та практиці впровадження концепції світового комп'ютера, більшість обчислень відбуваються на проміжному рівні. Останній рівень залишається лише для виконання важливих перевірок. Майже всі ці перевірки в мульти-ланцюжковій архітектурі пов'язані з конкатенацією або злиттям заголовків блоків.\n\n\nНа останньому етапі нашої подорожі найважливішим елементом в інформаційному блоку світового комп'ютера стає кутовий камінь - заголовок. Другий компонент більше стосується мета-інформації. Якщо заголовок є фактичним результатом всіх обчислень, додаткова мета-інформація, яка передається, складається з квитанцій та підписів валідаторів, які брали участь на проміжному етапі цього процесу. На останньому етапі ми можемо візуалізувати цілу картину виключно як збірку того ж самого дерева, а не як список транзакцій. У фінальній частині реле-ланцюга ключовим аспектом є збірка заголовків з багатьох схожих процесів, але пов'язаних з різними сегментами світового комп'ютера, різними паралелями.\n\nКожна паралеля, кожний набір валідаторів - ми обгворили один приклад, але насправді такі підготовки блоків для паралелей відбуваються 30-40 разів. Кількість слотів паралелей або кількість L2 мереж в Ethereum призведе до подібної кількості процесів з подібною архітектурою. Однак на фінальному етапі ми побачимо приблизно ідентичну картину всюди - як буде сформований заголовок блоку з множини заголовків з інших блоків. У цьому процесі нам потрібно ввести ще одну сутність і перескочити через межу на другий етап.\n\nФіналізатори. Фактично, вони також є валідаторами, але валідаторами реле-ланцюга. У архітектурі Polkadot ми маємо тисячу валідаторів, розділених на дві групи. Перша, дуже мала група, відповідає лише за формування заголовка блоку та нового блоку, що складається з заголовків блоків Стану блоків Стану. Друга група - валідатори паралелей - поділяється на багато підгруп, але ця група називається валідаторами паралелей. У L2 мережах над Ethereum ця історія з часом набуде більшого розуміння, більшої кількості знаменників. Наразі давайте зосередимося на архітектурі Polkadot. Фіналізатори, крім перевірки додаткового набору мета-інформації та повторної перевірки валідатора з конкретним ID, випадково обраного для генерації цього блоку з усіх блоків, також допомагають повторно перевірити мета-інформацію, перевірити та зібрати всі заголовки в один. Це трохи складно, так, якщо ми дивимося на це з точки зору збірки дерева.\n\nКрім того, в архітектурі Polkadot та в Ethereum з останніми змінами відбувається перевірка доступності даних. Для цього фіналізатори відвідують валідаторів парачейнів і намагаються запитати фактичну інформацію про кожний блок, збережений в мережі. Якщо вони отримують дані від принаймні 1/3 валідаторів, використовуючи технологію, яка дозволяє резервне зберігання інформації, і в подальшому, якщо хтось втратить її, один, два або три валідатори все ще можуть відновити її, існує критичний поріг на рівні 1/3. Якщо 1/3 вузлів відповідають і кажуть, що у нас є дані про блок, який виробляється, фіналізатори повідомляють блок, що це вже повністю сформований інформаційний блок, що всі обчислення були виконані правильно, що ми вже взяли заголовок цього блоку і поєднали його з заголовками інших сегментів мережі. Ми вже сформували головний заголовок всієї мережі. Після цього фіналізатори розміщують багато позначок на кінцевому блоку, який поєднує всі виконані обчислення.\n\nНаразі це ситуація з точки зору найбільш інженерно реалізованої багатоланкової гетерогенної екосистеми, якою є Polkadot. Це найбільш інженерно реалізована багатоланкова гетерогенна екосистема, не занадто далека від Ethereum. Я б хотів зосередитися на порівнянні, і якщо хтось зацікавлений у розумінні того, як інформаційні блоки потоком в Ethereum з мережами L2, ви можете спробувати це зараз. Я повернуся до цього питання, коли деякі елементи Ethereum, з точки зору гетерогенності та багатоланкоих аспектів, будуть завершені. Це може зайняти 1-2 роки, і тоді ми зможемо побудувати таку картину. Тим не менш, ми можемо загалом прийняти схему з трьох основних етапів.\n\n**1. Формування кандидата на інформаційний блок:**\n   - На цьому етапі формується початковий кандидат на інформаційний блок.\n\n\n**2. Виконання всіх обчислень, зберігання даних, доступність даних, перевірка з іншими вузлами, забезпечення того, що всі переходи стану виконуються правильно згідно з конкретними алгоритмами, та зберігання цих алгоритмів у головному цитаделі:**\n   - На цьому етапі відбувається фактичне виконання обчислень, збереження даних на певних рівнях, забезпечення доступності даних, перевірка з іншими вузлами для підтвердження того, що всі переходи стану відповідають алгоритмам, збереженим десь у головному цитаделі.\n\n\n**3. Фіналізація, яка не буде перевіряти обчислення, але переврить мета-інформацію, як ця мета-інформація зберігається. Потім вона зібере остаточний блок, який є станом станів, і випустить його як загальний інформаційний блок для всієї сегментованої мульти-ланцюжкової мережі:**\n   - Останній етап включає перевірку мета-інформації, перевірку того, як ця мета-інформація зберігається, збирання остаточного блоку (стан станів) та випуск його як загального інформаційного блоку для всієї сегментованої мульти-ланцюжкової мережі.\n\n\nНа цьому етапі ми можемо сказати, що наша інформація збережена. Вона пройшла через серце, серце виконало свій перенос даних правильно, і ми вже можемо використовувати вихідні значення. Деякі використовуватимуть їх, щоб відкрити квартиру, куплену за допомогою розумного контракту  розумним замком, тоді як інші можуть показати свій NFT, щойно отриманий за 10 ефірів.\n\nЗагалом, це приблизно так працює. Це завершує теоретичну частину. Я думаю, що це зайняло близько 2 годин, і перед нами практичні сесії, які я буду записувати протягом наступних кількох місяців. Вони допоможуть нам зрозуміти спостережені дані з вікон консолі, децентралізовані додатки, блок-дослідники, де ми поступово зрозуміємо, як всі ці теоретичні цифри та літери фактично виглядають у реалізації, використовуючи Polkadot як приклад. Я також почну працювати на практиці з реалізаціями на рівні L2 за допомогою одного з відомих фреймворків для побудови L2. Дякую всім, хто дивився.\n","fileInfo":{"path":"uk/learn/world-computer/the-path-of-a-new-block-of-information-in-the-world-computer.md","name":"the-path-of-a-new-block-of-information-in-the-world-computer"},"defaultName":"World computer in your home","lastUpdate":null}},"context":{}}